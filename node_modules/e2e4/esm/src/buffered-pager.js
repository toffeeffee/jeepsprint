var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { filter } from './filter-annotation';
/**
 * Implements {@link Pager} contract and represents buffered list behavior.
 * @note This type is configured to use with {@link FiltersService}.
 */
export class BufferedPager {
    constructor() {
        /**
         * @inheritdoc
         */
        this.appendedOnLoad = true;
        /**
         * @inheritdoc
         */
        this.totalCount = 0;
        /**
         * @inheritdoc
         */
        this.loadedCount = 0;
        /**
         * This is both initial value and value which will be applied to {@link takeRowCount} property on {@link reset} method execution.
         */
        this.defaultRowCount = BufferedPager.settings.defaultRowCount;
        /**
         * The smallest value that can be applied to {@link takeRowCount} property.
         */
        this.minRowCount = BufferedPager.settings.minRowCount;
        /**
         * The biggest value that can be applied to {@link takeRowCount} property.
         */
        this.maxRowCount = BufferedPager.settings.maxRowCount;
        /**
         * This property is applied to the server request and it specifies how many rows are already loaded and must be skipped on next request.
         *
         * @note This property is ready to use with {@link FiltersService} since it has {@link filter} annotation.
         * @see {@link BufferedListRequest.skip}
         */
        this.skip = 0;
        /**
         * Internal implementation of {@link takeRowCount}.
         */
        this.takeRowCountInternal = BufferedPager.settings.defaultRowCount;
        this.handlesFlatResponse = false;
        this.lastChunkRecieved = null;
    }
    /**
     * This property is applied to the server request and it specifies how many rows must be loaded on next request.
     * @note This property is ready to use with {@link FiltersService} since it has {@link filter} annotation.
     * @see {@link BufferedListRequest.take}
     */
    get takeRowCount() {
        return this.takeRowCountInternal;
    }
    /**
     * Executes several checks. For example, it doesn't accept values bigger than {@link maxRowCount}.
     */
    set takeRowCount(value) {
        const valueStr = (value + '').replace(/[^0-9]/g, '');
        let rowCount = parseInt(valueStr, 10) ? parseInt(valueStr, 10) : this.defaultRowCount;
        if (rowCount < this.minRowCount) {
            rowCount = this.defaultRowCount;
        }
        if (rowCount > this.maxRowCount) {
            rowCount = this.maxRowCount;
        }
        if (this.totalCount !== 0) {
            if (this.skip + rowCount > this.totalCount) {
                rowCount = this.totalCount - this.skip;
            }
        }
        this.takeRowCountInternal = rowCount;
    }
    /**
     * Returns `true` if it's possible to load more records (e.g. currently not all records loaded to the list).
     */
    get canLoadMore() {
        return this.totalCount !== 0 && this.handlesFlatResponse
            ? !this.lastChunkRecieved
            : this.skip < this.totalCount;
    }
    /**
     * @inheritdoc
     */
    processResponse(response) {
        let alignedResponse;
        if (Array.isArray(response)) {
            this.handlesFlatResponse = true;
            alignedResponse = {
                items: response,
                loadedCount: response.length,
                totalCount: response.length
            };
        }
        else {
            this.handlesFlatResponse = false;
            alignedResponse = response;
        }
        this.totalCount = alignedResponse.totalCount || 0;
        const lastLoadedCount = alignedResponse.loadedCount ||
            (alignedResponse.items && alignedResponse.items.length ? alignedResponse.items.length : 0);
        this.lastChunkRecieved = lastLoadedCount !== this.takeRowCountInternal;
        this.skip = this.skip + lastLoadedCount;
        this.loadedCount = this.skip;
    }
    /**
     * @inheritdoc
     */
    reset() {
        this.totalCount = 0;
        this.loadedCount = 0;
        this.takeRowCount = this.defaultRowCount;
        this.skip = 0;
    }
}
/**
 * Global settings for properties such as default values and constraints for pager properties.
 *
 * These settings are static and their values are copied to the properties of the same name for each instance of {@link BufferedPager} type.
 *
 * So, changing of this settings will affect all instances of {@link BufferedPager} type that will be created after such changes.
 * If you want to change settings of concrete object you can use it the same name properties.
 */
// tslint:disable-next-line: typedef
BufferedPager.settings = {
    /**
     * @see {@link BufferedPager.defaultRowCount}
     */
    defaultRowCount: 20,
    /**
     * @see {@link BufferedPager.maxRowCount}
     */
    maxRowCount: 200,
    /**
     * @see {@link BufferedPager.minRowCount}
     */
    minRowCount: 1
};
__decorate([
    filter({
        defaultValue: 0,
        parameterName: 'skip',
        parseFormatter() {
            return 0;
        }
    }),
    __metadata("design:type", Number)
], BufferedPager.prototype, "skip", void 0);
__decorate([
    filter({
        defaultValue() {
            return this.defaultRowCount;
        },
        parameterName: 'take',
        parseFormatter(rawValue, allValues) {
            let result;
            if (allValues && !isNaN(allValues.skip) && !isNaN(allValues.take)) {
                result = (allValues.skip || 0) + (allValues.take || 0);
            }
            return result || this.defaultRowCount;
        }
    }),
    __metadata("design:type", Number)
], BufferedPager.prototype, "takeRowCountInternal", void 0);
//# sourceMappingURL=buffered-pager.js.map