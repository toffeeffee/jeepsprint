// tslint:disable:max-classes-per-file
/**
 * Implementation of {@link SubscriptionProxy} to work with any objects with `subscribe/unsubscribe` contracts. This contract is suitable for Observable, for example.
 */
export class PushBasedSubscriptionProxy {
    /**
     * @inheritdoc
     */
    attach(target, completeAction, errorAction) {
        return target.subscribe({ error: errorAction, next: completeAction });
    }
    /**
     * @inheritdoc
     */
    detach(subscription) {
        subscription.unsubscribe();
    }
    /**
     * Returns `true` if this proxy type can subscribe to passed object. `false` otherwise.
     */
    static isAcceptable(target) {
        return !!target.subscribe;
    }
}
/**
 * Implementation of {@link SubscriptionProxy} which works with Promise and adds ability to unsubscribe from it.
 */
export class PromiseSubscriptionProxy {
    constructor() {
        this.isAlive = true;
    }
    /**
     * @inheritdoc
     */
    attach(target, completeAction, errorAction) {
        return target.then((value) => {
            if (this.isAlive) {
                completeAction(value);
            }
        }, (error) => {
            if (this.isAlive) {
                errorAction(error);
            }
        });
    }
    /**
     * @inheritdoc
     */
    detach(subscription) {
        this.isAlive = false;
    }
    /**
     * Returns `true` if this proxy type can subscribe to passed object. `false` otherwise.
     */
    static isAcceptable(target) {
        return target instanceof Promise;
    }
}
/**
 * Service to manage async subscriptions which acts as mediator to {@link SubscriptionProxy} contract implementations.
 */
export class AsyncSubscriber {
    constructor() {
        this.proxy = null;
        this.lastTarget = null;
        this.subscription = null;
    }
    /**
     * @see {@link SubscriptionProxy.attach}
     */
    attach(target, completeAction, errorAction) {
        if (this.lastTarget !== null) {
            this.destroy();
        }
        this.lastTarget = target;
        this.proxy = this.getProxy(target);
        this.subscription = this.proxy.attach(target, completeAction, errorAction);
    }
    /**
     * Detaches from underlying subscription and destroys all internal objects.
     */
    destroy() {
        if (this.proxy) {
            this.proxy.detach(this.subscription);
        }
        this.proxy = null;
        this.lastTarget = null;
        this.subscription = null;
    }
    /**
     * @see {@link SubscriptionProxy.detach}
     */
    detach() {
        this.proxy.detach(this.subscription);
    }
    getProxy(target) {
        if (PromiseSubscriptionProxy.isAcceptable(target)) {
            return new PromiseSubscriptionProxy();
        }
        if (PushBasedSubscriptionProxy.isAcceptable(target)) {
            return new PushBasedSubscriptionProxy();
        }
        throw new Error("Can't subscribe to passed object");
    }
}
//# sourceMappingURL=async-subscriber.js.map