import { AsyncSubscriber } from './async-subscriber';
import { FilterConfig } from './contracts/filter-config';
import { ListResponse } from './contracts/list-response';
import { OperationStatus } from './contracts/operation-status';
import { Pager } from './contracts/pager';
import { FiltersService } from './filters-service';
import { SortingsService } from './sortings-service';
import { StateService } from './state-service';
export declare class List {
    protected asyncSubscriber: AsyncSubscriber;
    protected sortingsService: SortingsService;
    protected filtersService: FiltersService;
    /**
     * Global settings of list..
     *
     * These settings are static and their values are copied to the properties of the same name for each instance of {@link List} type.
     *
     * So, changing of this settings will affect all instances of {@link List} type that will be created after such changes.
     * If you want to change settings of concrete object you can use it the same name properties.
     */
    static settings: {
        /**
         * @see {@link List.keepRecordsOnLoad}
         */
        keepRecordsOnLoad: boolean;
    };
    /**
     * Specifies that list must destroy previously loaded records immediately or keep them until data request is completed.
     */
    keepRecordsOnLoad: boolean;
    /**
     * Method for getting data. This parameter is required and its configuration is necessary.
     *
     * This method get one parameter with the settings of the request implementing {@link ListRequest} contract for the simple lists and {@link PagedListRequest} one for the paged lists.
     * The return value of this method should be any subscribable object which can be handled by {@link AsyncSubscriber}.
     * For the simple lists the response should contain array with the records. As for the paged ones, it should implement {@link ListResponse} contract.
     */
    fetchMethod: (requestParams: any) => any;
    /**
     * Array of elements transferred in the {@link ListResponse.items} property.
     */
    items: any[];
    /**
     * Array of registered {@link StateService} instances.
     */
    stateServices: StateService[];
    protected pagerInternal: Pager;
    protected statusInternal: OperationStatus;
    protected destroyedInternal: boolean;
    protected initedInternal: boolean;
    /**
     * Configured {@link Pager} service.
     */
    pager: Pager;
    /**
     * True if the service was already destroyed via {@link destroy} call.
     */
    readonly destroyed: boolean;
    /**
     * True if the service was already initialized via {@link init} call.
     */
    readonly inited: boolean;
    /**
     * Current execution status of the list.
     */
    readonly status: OperationStatus;
    /**
     * returns `true`, if there is a data request executed at the moment (i.e. {@link state} is equal to {@link ProgressState.Progress})
     */
    readonly busy: boolean;
    /**
     * returns `true`, if there is no data request executed at the moment (i.e. {@link state} is NOT equal to {@link ProgressState.Progress})
     */
    readonly ready: boolean;
    constructor(asyncSubscriber: AsyncSubscriber, stateServices: StateService | StateService[], sortingsService: SortingsService, filtersService: FiltersService);
    /**
     * Performs initialization logic of the service. This method must be called before first use of the service.
     */
    init(): void;
    /**
     * Performs destroy logic of the list itself and all of the inner services.
     */
    destroy(): void;
    /**
     * Registers passed object(s) as state service to manage the list state.
     */
    registerStateService(...services: StateService[]): void;
    /**
     * Removes passed object(s) from state services collection of the list.
     */
    removeStateService(...services: StateService[]): void;
    /**
     * Registers passed object(s) as filter targets in underlying {@link FiltersService} to include their configured properties as parameters to the data request.
     * @see {@link FiltersService.registerFilterTarget}
     */
    registerFilterTarget(...targets: object[]): void;
    /**
     * @see {@link FiltersService.removeFilterTarget}
     */
    removeFilterTarget(...targets: object[]): void;
    /**
     * @see {@link FiltersService.getRequestState}
     */
    getRequestState(filterFn?: (config: FilterConfig, proposedValue: any, targetObject: object) => boolean): any;
    /**
     * Resets the list parameters (sortings, paging, filters) to their default values.
     */
    resetSettings(): void;
    /**
     * Cancels the request executed at the moment.
     */
    cancelRequests(): void;
    /**
     * Clears {@link items} array. Calls {@link destroyAll} method for {@link items} array to perform optional destroy logic of the elements.
     * {@see destroyAll}
     */
    clearData(): void;
    /**
     * Performs data loading by calling specified {@link fetchMethod} delegate.
     * @return result of {@link fetchMethod} execution.
     */
    loadData(): any;
    /**
     * Resets paging parameters and performs data loading by calling {@link loadData} if list not in {@link OperationStatus.Progress} state.
     * @return result of {@link fetchMethod} if it was called. `null` otherwise.
     */
    reloadData(): any;
    /**
     * Callback which is executed if {@link fetchMethod} execution finished successfully.
     */
    loadSuccessCallback(response: ListResponse<any> | any[]): ListResponse<any> | any[];
    /**
     * Callback which is executed if {@link fetchMethod} execution finished with error.
     */
    loadFailCallback(): void;
    private loadDataSuccessCallback;
    private reloadDataSuccessCallback;
    private loadDataFailCallback;
    private tryInterceptStatusResponse;
    private reloadDataFailCallback;
    private tryCleanItemsOnLoad;
    private tryCleanItemsOnReload;
    private beginRequest;
    private responseHasStatus;
}
