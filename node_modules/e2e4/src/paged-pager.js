"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var filter_annotation_1 = require("./filter-annotation");
/**
 * Implements {@link Pager} contract and represents behavior of list with pages.
 * @note This type is configured to use with {@link FiltersService}.
 */
var PagedPager = /** @class */ (function () {
    function PagedPager() {
        /**
         * @inheritdoc
         */
        this.appendedOnLoad = false;
        /**
         * This is both initial value and value which will be applied to {@link pageSize} property on {@link reset} method execution.
         */
        this.defaultPageSize = PagedPager.settings.defaultPageSize;
        /**
         * The biggest value that can be applied to {@link pageSize} property.
         */
        this.maxPageSize = PagedPager.settings.maxPageSize;
        /**
         * The smallest value that can be applied to {@link pageSize} property.
         */
        this.minPageSize = PagedPager.settings.minPageSize;
        /**
         * @inheritdoc
         */
        this.totalCount = 0;
        /**
         * @inheritdoc
         */
        this.loadedCount = 0;
        /**
         * Number of record in remote data source from which data was loaded at last request.
         *
         * For example, it will be equal to 21 when loads second page of list with page size of 20.
         */
        this.displayFrom = 0;
        /**
         * Number of record in remote data source to which data was loaded at last request.
         *
         * For example, it will be equal to 40 when loads second page of list with page size of 20. Or it will be equal to total count of available records if records count is less than 40.
         */
        this.displayTo = 0;
        /**
         * Internal implementation of {@link pageSize}.
         */
        this.pageSizeInternal = PagedPager.settings.defaultPageSize;
        /**
         * Internal implementation of {@link pageNumber}.
         */
        this.pageNumberInternal = 1;
    }
    Object.defineProperty(PagedPager.prototype, "pageCount", {
        /**
         * Total pages count computed as {@link totalCount} / {@link pageSize}.
         * Used to check correctness of values applied to {@link pageNumber}.
         */
        get: function () {
            return Math.ceil(this.totalCount / this.pageSizeInternal);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedPager.prototype, "pageNumber", {
        /**
         * Specifies number of the page that must be loaded on next request.
         *
         * @note This property is ready to use with {@link FiltersService} since it has {@link filter} annotation.
         * @see {@link PagedListRequest.pageNumber}
         */
        get: function () {
            return this.pageNumberInternal;
        },
        /**
         * Executes several checks. For example, it doesn't accept values bigger than {@link pageCount}.
         */
        set: function (value) {
            var valueStr = (value + '').replace(/[^0-9]/g, '');
            var pageNumber = parseInt(valueStr, 10) ? parseInt(valueStr, 10) : 1;
            if (pageNumber > this.pageCount) {
                pageNumber = this.pageCount;
            }
            if (pageNumber < 1) {
                pageNumber = 1;
            }
            this.pageNumberInternal = pageNumber;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedPager.prototype, "pageSize", {
        /**
         * Specifies size of page that must be loaded on next request.
         *
         * @note This property is ready to use with {@link FiltersService} since it has {@link filter} annotation.
         * @see {@link PagedListRequest.pageSize}
         */
        get: function () {
            return this.pageSizeInternal;
        },
        /**
         * Executes several checks. For example, it doesn't accept values bigger than {@link maxPageSize}.
         */
        set: function (value) {
            var valueStr = (value + '').replace(/[^0-9]/g, '');
            var pageSize = parseInt(valueStr, 10) ? parseInt(valueStr, 10) : this.defaultPageSize;
            if (this.totalCount !== 0) {
                if (pageSize > this.totalCount) {
                    pageSize = this.totalCount;
                }
                if (this.pageNumber * pageSize > this.totalCount) {
                    pageSize = Math.ceil(this.totalCount / this.pageNumber);
                }
            }
            if (pageSize > this.maxPageSize) {
                pageSize = this.maxPageSize;
            }
            if (pageSize < this.minPageSize || pageSize === 0) {
                pageSize = this.defaultPageSize;
            }
            this.pageSizeInternal = pageSize;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritdoc
     */
    PagedPager.prototype.processResponse = function (response) {
        var alignedResponse;
        if (Array.isArray(response)) {
            alignedResponse = {
                items: response,
                loadedCount: response.length,
                totalCount: response.length
            };
        }
        else {
            alignedResponse = response;
        }
        this.loadedCount =
            alignedResponse.loadedCount ||
                (alignedResponse.items && alignedResponse.items.length ? alignedResponse.items.length : 0);
        this.totalCount = alignedResponse.totalCount || 0;
        var skippedCount = this.pageSize * (this.pageNumber - 1);
        this.displayFrom = skippedCount + 1;
        this.displayTo = this.displayFrom + this.loadedCount - 1;
    };
    Object.defineProperty(PagedPager.prototype, "canMoveBackward", {
        /**
         * Returns `true` if it's possible to move pager to the previous page (e.g. currently pager is not on the first page).
         */
        get: function () {
            return this.pageCount !== 0 && this.pageNumber !== 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedPager.prototype, "canMoveForward", {
        /**
         * Returns `true` if it's possible to move pager to the next page (e.g. currently pager is not on the last page).
         */
        get: function () {
            return this.pageCount !== 0 && this.pageNumber < this.pageCount;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets {@link pageNumber} property to `1` if it's possible.
     * @returns `true` if {@link pageNumber} value was changed.
     */
    PagedPager.prototype.tryMoveToFirstPage = function () {
        if (this.canMoveBackward) {
            this.pageNumber = 1;
            return true;
        }
        return false;
    };
    /**
     * Decrements {@link pageNumber} if it's possible.
     * @returns `true` if {@link pageNumber} value was changed.
     */
    PagedPager.prototype.tryMoveToPreviousPage = function () {
        if (this.canMoveBackward) {
            this.pageNumber -= 1;
            return true;
        }
        return false;
    };
    /**
     * Increments {@link pageNumber} if it's possible.
     * @returns `true` if {@link pageNumber} value was changed.
     */
    PagedPager.prototype.tryMoveToNextPage = function () {
        if (this.canMoveForward) {
            this.pageNumber += 1;
            return true;
        }
        return false;
    };
    /**
     * Sets {@link pageNumber} property to value of {@link pageCount} property if it's possible.
     * @returns `true` if {@link pageNumber} value was changed.
     */
    PagedPager.prototype.tryMoveToLastPage = function () {
        if (this.canMoveForward) {
            this.pageNumber = this.pageCount;
            return true;
        }
        return false;
    };
    /**
     * @inheritdoc
     */
    PagedPager.prototype.reset = function () {
        this.totalCount = 0;
        this.loadedCount = 0;
        this.pageNumber = 1;
        this.pageSize = this.defaultPageSize;
    };
    /**
     * Global settings for properties such as default values and constraints for pager properties.
     *
     * These settings are static and their values are copied to the properties of the same name for each instance of {@link PagedPager} type.
     *
     * So, changing of this settings will affect all instances of {@link PagedPager} type that will be created after such changes.
     * If you want to change settings of concrete object you can use it the same name properties.
     */
    // tslint:disable-next-line: typedef
    PagedPager.settings = {
        /**
         * @see {@link PagedPager.defaultPageSize}
         */
        defaultPageSize: 20,
        /**
         * @see {@link PagedPager.maxPageSize}
         */
        maxPageSize: 200,
        /**
         * @see {@link PagedPager.minPageSize}
         */
        minPageSize: 1
    };
    __decorate([
        filter_annotation_1.filter({
            defaultValue: function () {
                return this.defaultPageSize;
            },
            parameterName: 'take',
            parseFormatter: function (rawValue) {
                return isNaN(rawValue) || !rawValue ? this.defaultPageSize : rawValue;
            }
        }),
        __metadata("design:type", Number)
    ], PagedPager.prototype, "pageSizeInternal", void 0);
    __decorate([
        filter_annotation_1.filter({
            defaultValue: 0,
            parameterName: 'skip',
            parseFormatter: function (rawValue, allValues) {
                var skip = isNaN(rawValue) || !rawValue ? 0 : rawValue;
                var pageSize = !allValues || isNaN(allValues.take) || !allValues.take ? this.defaultPageSize : allValues.take * 1;
                return skip % pageSize === 0 ? skip / pageSize + 1 : 1;
            },
            serializeFormatter: function () {
                return (this.pageNumber - 1) * this.pageSize;
            }
        }),
        __metadata("design:type", Number)
    ], PagedPager.prototype, "pageNumberInternal", void 0);
    return PagedPager;
}());
exports.PagedPager = PagedPager;
//# sourceMappingURL=paged-pager.js.map