"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var filter_annotation_1 = require("./filter-annotation");
/**
 * Implements {@link Pager} contract and represents buffered list behavior.
 * @note This type is configured to use with {@link FiltersService}.
 */
var BufferedPager = /** @class */ (function () {
    function BufferedPager() {
        /**
         * @inheritdoc
         */
        this.appendedOnLoad = true;
        /**
         * @inheritdoc
         */
        this.totalCount = 0;
        /**
         * @inheritdoc
         */
        this.loadedCount = 0;
        /**
         * This is both initial value and value which will be applied to {@link takeRowCount} property on {@link reset} method execution.
         */
        this.defaultRowCount = BufferedPager.settings.defaultRowCount;
        /**
         * The smallest value that can be applied to {@link takeRowCount} property.
         */
        this.minRowCount = BufferedPager.settings.minRowCount;
        /**
         * The biggest value that can be applied to {@link takeRowCount} property.
         */
        this.maxRowCount = BufferedPager.settings.maxRowCount;
        /**
         * This property is applied to the server request and it specifies how many rows are already loaded and must be skipped on next request.
         *
         * @note This property is ready to use with {@link FiltersService} since it has {@link filter} annotation.
         * @see {@link BufferedListRequest.skip}
         */
        this.skip = 0;
        /**
         * Internal implementation of {@link takeRowCount}.
         */
        this.takeRowCountInternal = BufferedPager.settings.defaultRowCount;
        this.handlesFlatResponse = false;
        this.lastChunkRecieved = null;
    }
    Object.defineProperty(BufferedPager.prototype, "takeRowCount", {
        /**
         * This property is applied to the server request and it specifies how many rows must be loaded on next request.
         * @note This property is ready to use with {@link FiltersService} since it has {@link filter} annotation.
         * @see {@link BufferedListRequest.take}
         */
        get: function () {
            return this.takeRowCountInternal;
        },
        /**
         * Executes several checks. For example, it doesn't accept values bigger than {@link maxRowCount}.
         */
        set: function (value) {
            var valueStr = (value + '').replace(/[^0-9]/g, '');
            var rowCount = parseInt(valueStr, 10) ? parseInt(valueStr, 10) : this.defaultRowCount;
            if (rowCount < this.minRowCount) {
                rowCount = this.defaultRowCount;
            }
            if (rowCount > this.maxRowCount) {
                rowCount = this.maxRowCount;
            }
            if (this.totalCount !== 0) {
                if (this.skip + rowCount > this.totalCount) {
                    rowCount = this.totalCount - this.skip;
                }
            }
            this.takeRowCountInternal = rowCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BufferedPager.prototype, "canLoadMore", {
        /**
         * Returns `true` if it's possible to load more records (e.g. currently not all records loaded to the list).
         */
        get: function () {
            return this.totalCount !== 0 && this.handlesFlatResponse
                ? !this.lastChunkRecieved
                : this.skip < this.totalCount;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritdoc
     */
    BufferedPager.prototype.processResponse = function (response) {
        var alignedResponse;
        if (Array.isArray(response)) {
            this.handlesFlatResponse = true;
            alignedResponse = {
                items: response,
                loadedCount: response.length,
                totalCount: response.length
            };
        }
        else {
            this.handlesFlatResponse = false;
            alignedResponse = response;
        }
        this.totalCount = alignedResponse.totalCount || 0;
        var lastLoadedCount = alignedResponse.loadedCount ||
            (alignedResponse.items && alignedResponse.items.length ? alignedResponse.items.length : 0);
        this.lastChunkRecieved = lastLoadedCount !== this.takeRowCountInternal;
        this.skip = this.skip + lastLoadedCount;
        this.loadedCount = this.skip;
    };
    /**
     * @inheritdoc
     */
    BufferedPager.prototype.reset = function () {
        this.totalCount = 0;
        this.loadedCount = 0;
        this.takeRowCount = this.defaultRowCount;
        this.skip = 0;
    };
    /**
     * Global settings for properties such as default values and constraints for pager properties.
     *
     * These settings are static and their values are copied to the properties of the same name for each instance of {@link BufferedPager} type.
     *
     * So, changing of this settings will affect all instances of {@link BufferedPager} type that will be created after such changes.
     * If you want to change settings of concrete object you can use it the same name properties.
     */
    // tslint:disable-next-line: typedef
    BufferedPager.settings = {
        /**
         * @see {@link BufferedPager.defaultRowCount}
         */
        defaultRowCount: 20,
        /**
         * @see {@link BufferedPager.maxRowCount}
         */
        maxRowCount: 200,
        /**
         * @see {@link BufferedPager.minRowCount}
         */
        minRowCount: 1
    };
    __decorate([
        filter_annotation_1.filter({
            defaultValue: 0,
            parameterName: 'skip',
            parseFormatter: function () {
                return 0;
            }
        }),
        __metadata("design:type", Number)
    ], BufferedPager.prototype, "skip", void 0);
    __decorate([
        filter_annotation_1.filter({
            defaultValue: function () {
                return this.defaultRowCount;
            },
            parameterName: 'take',
            parseFormatter: function (rawValue, allValues) {
                var result;
                if (allValues && !isNaN(allValues.skip) && !isNaN(allValues.take)) {
                    result = (allValues.skip || 0) + (allValues.take || 0);
                }
                return result || this.defaultRowCount;
            }
        }),
        __metadata("design:type", Number)
    ], BufferedPager.prototype, "takeRowCountInternal", void 0);
    return BufferedPager;
}());
exports.BufferedPager = BufferedPager;
//# sourceMappingURL=buffered-pager.js.map