"use strict";
// tslint:disable:max-classes-per-file
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Implementation of {@link SubscriptionProxy} to work with any objects with `subscribe/unsubscribe` contracts. This contract is suitable for Observable, for example.
 */
var PushBasedSubscriptionProxy = /** @class */ (function () {
    function PushBasedSubscriptionProxy() {
    }
    /**
     * @inheritdoc
     */
    PushBasedSubscriptionProxy.prototype.attach = function (target, completeAction, errorAction) {
        return target.subscribe({ error: errorAction, next: completeAction });
    };
    /**
     * @inheritdoc
     */
    PushBasedSubscriptionProxy.prototype.detach = function (subscription) {
        subscription.unsubscribe();
    };
    /**
     * Returns `true` if this proxy type can subscribe to passed object. `false` otherwise.
     */
    PushBasedSubscriptionProxy.isAcceptable = function (target) {
        return !!target.subscribe;
    };
    return PushBasedSubscriptionProxy;
}());
exports.PushBasedSubscriptionProxy = PushBasedSubscriptionProxy;
/**
 * Implementation of {@link SubscriptionProxy} which works with Promise and adds ability to unsubscribe from it.
 */
var PromiseSubscriptionProxy = /** @class */ (function () {
    function PromiseSubscriptionProxy() {
        this.isAlive = true;
    }
    /**
     * @inheritdoc
     */
    PromiseSubscriptionProxy.prototype.attach = function (target, completeAction, errorAction) {
        var _this = this;
        return target.then(function (value) {
            if (_this.isAlive) {
                completeAction(value);
            }
        }, function (error) {
            if (_this.isAlive) {
                errorAction(error);
            }
        });
    };
    /**
     * @inheritdoc
     */
    PromiseSubscriptionProxy.prototype.detach = function (subscription) {
        this.isAlive = false;
    };
    /**
     * Returns `true` if this proxy type can subscribe to passed object. `false` otherwise.
     */
    PromiseSubscriptionProxy.isAcceptable = function (target) {
        return target instanceof Promise;
    };
    return PromiseSubscriptionProxy;
}());
exports.PromiseSubscriptionProxy = PromiseSubscriptionProxy;
/**
 * Service to manage async subscriptions which acts as mediator to {@link SubscriptionProxy} contract implementations.
 */
var AsyncSubscriber = /** @class */ (function () {
    function AsyncSubscriber() {
        this.proxy = null;
        this.lastTarget = null;
        this.subscription = null;
    }
    /**
     * @see {@link SubscriptionProxy.attach}
     */
    AsyncSubscriber.prototype.attach = function (target, completeAction, errorAction) {
        if (this.lastTarget !== null) {
            this.destroy();
        }
        this.lastTarget = target;
        this.proxy = this.getProxy(target);
        this.subscription = this.proxy.attach(target, completeAction, errorAction);
    };
    /**
     * Detaches from underlying subscription and destroys all internal objects.
     */
    AsyncSubscriber.prototype.destroy = function () {
        if (this.proxy) {
            this.proxy.detach(this.subscription);
        }
        this.proxy = null;
        this.lastTarget = null;
        this.subscription = null;
    };
    /**
     * @see {@link SubscriptionProxy.detach}
     */
    AsyncSubscriber.prototype.detach = function () {
        this.proxy.detach(this.subscription);
    };
    AsyncSubscriber.prototype.getProxy = function (target) {
        if (PromiseSubscriptionProxy.isAcceptable(target)) {
            return new PromiseSubscriptionProxy();
        }
        if (PushBasedSubscriptionProxy.isAcceptable(target)) {
            return new PushBasedSubscriptionProxy();
        }
        throw new Error("Can't subscribe to passed object");
    };
    return AsyncSubscriber;
}());
exports.AsyncSubscriber = AsyncSubscriber;
//# sourceMappingURL=async-subscriber.js.map