"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var operation_status_1 = require("./contracts/operation-status");
var null_object_pager_1 = require("./null-object-pager");
var utilities_1 = require("./utilities");
var List = /** @class */ (function () {
    function List(asyncSubscriber, stateServices, sortingsService, filtersService) {
        var _a;
        var _this = this;
        this.asyncSubscriber = asyncSubscriber;
        this.sortingsService = sortingsService;
        this.filtersService = filtersService;
        /**
         * Specifies that list must destroy previously loaded records immediately or keep them until data request is completed.
         */
        this.keepRecordsOnLoad = List.settings.keepRecordsOnLoad;
        /**
         * Array of elements transferred in the {@link ListResponse.items} property.
         */
        this.items = new Array();
        /**
         * Array of registered {@link StateService} instances.
         */
        this.stateServices = new Array();
        this.statusInternal = operation_status_1.OperationStatus.Initial;
        this.destroyedInternal = false;
        this.initedInternal = false;
        this.loadDataSuccessCallback = function (response) {
            if (_this.tryInterceptStatusResponse(response)) {
                return response;
            }
            _this.tryCleanItemsOnLoad(true);
            return _this.loadSuccessCallback(response);
        };
        this.reloadDataSuccessCallback = function (response) {
            if (_this.tryInterceptStatusResponse(response)) {
                return response;
            }
            _this.tryCleanItemsOnReload(true);
            return _this.loadSuccessCallback(response);
        };
        this.loadDataFailCallback = function () {
            _this.tryCleanItemsOnLoad(true);
            _this.loadFailCallback();
        };
        this.reloadDataFailCallback = function () {
            _this.tryCleanItemsOnReload(true);
            _this.loadFailCallback();
        };
        if (stateServices != null) {
            if (Array.isArray(stateServices)) {
                (_a = this.stateServices).push.apply(_a, (stateServices));
            }
            else {
                this.stateServices.push(stateServices);
            }
        }
        this.pager = new null_object_pager_1.NullObjectPager();
    }
    Object.defineProperty(List.prototype, "pager", {
        /**
         * Configured {@link Pager} service.
         */
        get: function () {
            return this.pagerInternal;
        },
        set: function (value) {
            this.filtersService.removeFilterTarget(this.pagerInternal);
            this.pagerInternal = value;
            this.filtersService.registerFilterTarget(this.pagerInternal);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "destroyed", {
        /**
         * True if the service was already destroyed via {@link destroy} call.
         */
        get: function () {
            return this.destroyedInternal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "inited", {
        /**
         * True if the service was already initialized via {@link init} call.
         */
        get: function () {
            return this.initedInternal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "status", {
        /**
         * Current execution status of the list.
         */
        get: function () {
            return this.statusInternal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "busy", {
        /**
         * returns `true`, if there is a data request executed at the moment (i.e. {@link state} is equal to {@link ProgressState.Progress})
         */
        get: function () {
            return this.status === operation_status_1.OperationStatus.Progress;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "ready", {
        /**
         * returns `true`, if there is no data request executed at the moment (i.e. {@link state} is NOT equal to {@link ProgressState.Progress})
         */
        get: function () {
            return this.status !== operation_status_1.OperationStatus.Progress;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Performs initialization logic of the service. This method must be called before first use of the service.
     */
    List.prototype.init = function () {
        if (this.inited) {
            return;
        }
        this.filtersService.registerFilterTarget(this.pager, this.sortingsService);
        var restoredState = {};
        Object.assign.apply(Object, [restoredState].concat(this.stateServices.map(function (service) { return service.getState() || {}; })));
        this.filtersService.applyParams(restoredState);
        this.initedInternal = true;
    };
    /**
     * Performs destroy logic of the list itself and all of the inner services.
     */
    List.prototype.destroy = function () {
        this.asyncSubscriber.destroy();
        this.filtersService.destroy();
        this.sortingsService.destroy();
        this.clearData();
        this.destroyedInternal = true;
    };
    /**
     * Registers passed object(s) as state service to manage the list state.
     */
    List.prototype.registerStateService = function () {
        var _this = this;
        var services = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            services[_i] = arguments[_i];
        }
        services.forEach(function (service) {
            _this.stateServices.push(service);
        });
    };
    /**
     * Removes passed object(s) from state services collection of the list.
     */
    List.prototype.removeStateService = function () {
        var _this = this;
        var services = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            services[_i] = arguments[_i];
        }
        services.forEach(function (service) {
            var index = _this.stateServices.findIndex(function (s) { return s === service; });
            if (index !== -1) {
                _this.stateServices.splice(index, 1);
            }
        });
    };
    /**
     * Registers passed object(s) as filter targets in underlying {@link FiltersService} to include their configured properties as parameters to the data request.
     * @see {@link FiltersService.registerFilterTarget}
     */
    List.prototype.registerFilterTarget = function () {
        var targets = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            targets[_i] = arguments[_i];
        }
        var _a;
        (_a = this.filtersService).registerFilterTarget.apply(_a, targets);
    };
    /**
     * @see {@link FiltersService.removeFilterTarget}
     */
    List.prototype.removeFilterTarget = function () {
        var targets = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            targets[_i] = arguments[_i];
        }
        var _a;
        (_a = this.filtersService).removeFilterTarget.apply(_a, targets);
    };
    /**
     * @see {@link FiltersService.getRequestState}
     */
    List.prototype.getRequestState = function (filterFn) {
        return this.filtersService.getRequestState(filterFn);
    };
    /**
     * Resets the list parameters (sortings, paging, filters) to their default values.
     */
    List.prototype.resetSettings = function () {
        this.filtersService.resetValues();
    };
    /**
     * Cancels the request executed at the moment.
     */
    List.prototype.cancelRequests = function () {
        if (this.busy) {
            this.asyncSubscriber.detach();
            this.statusInternal = operation_status_1.OperationStatus.Cancelled;
            this.clearData();
        }
    };
    /**
     * Clears {@link items} array. Calls {@link destroyAll} method for {@link items} array to perform optional destroy logic of the elements.
     * {@see destroyAll}
     */
    List.prototype.clearData = function () {
        utilities_1.destroyAll(this.items);
        this.items = [];
    };
    /**
     * Performs data loading by calling specified {@link fetchMethod} delegate.
     * @return result of {@link fetchMethod} execution.
     */
    List.prototype.loadData = function () {
        var _this = this;
        if (this.busy) {
            return null;
        }
        var subscribable = this.beginRequest();
        this.tryCleanItemsOnLoad(false);
        this.asyncSubscriber.attach(subscribable, this.loadDataSuccessCallback, this.loadDataFailCallback);
        this.stateServices.forEach(function (service) {
            service.persistState(_this.filtersService);
        });
        return subscribable;
    };
    /**
     * Resets paging parameters and performs data loading by calling {@link loadData} if list not in {@link OperationStatus.Progress} state.
     * @return result of {@link fetchMethod} if it was called. `null` otherwise.
     */
    List.prototype.reloadData = function () {
        var _this = this;
        if (this.busy) {
            return null;
        }
        this.pager.reset();
        var subscribable = this.beginRequest();
        this.tryCleanItemsOnReload(false);
        this.asyncSubscriber.attach(subscribable, this.reloadDataSuccessCallback, this.reloadDataFailCallback);
        this.stateServices.forEach(function (service) {
            service.persistState(_this.filtersService);
        });
        return subscribable;
    };
    /**
     * Callback which is executed if {@link fetchMethod} execution finished successfully.
     */
    List.prototype.loadSuccessCallback = function (response) {
        var items = Array.isArray(response) ? response : response.items;
        this.items = this.items.concat(items);
        this.pager.processResponse(response);
        // In case when filter changed from last request and there's no data now
        // Don't do this for flat responses since we don't know real count items
        if (!Array.isArray(response) && this.pager.totalCount === 0) {
            this.clearData();
            this.pager.reset();
        }
        this.statusInternal =
            this.pager.totalCount === 0 && this.items.length === 0 ? operation_status_1.OperationStatus.NoData : operation_status_1.OperationStatus.Done;
        return response;
    };
    /**
     * Callback which is executed if {@link fetchMethod} execution finished with error.
     */
    List.prototype.loadFailCallback = function () {
        this.tryCleanItemsOnLoad(true);
        this.statusInternal = operation_status_1.OperationStatus.Fail;
    };
    List.prototype.tryInterceptStatusResponse = function (response) {
        if (this.responseHasStatus(response)) {
            switch (response.status) {
                case operation_status_1.OperationStatus.Fail:
                    this.reloadDataFailCallback();
                    return true;
                case operation_status_1.OperationStatus.Cancelled:
                    this.cancelRequests();
                    return true;
                case operation_status_1.OperationStatus.Progress:
                    return true;
            }
        }
        return false;
    };
    List.prototype.tryCleanItemsOnLoad = function (requestCompleted) {
        if (this.keepRecordsOnLoad === requestCompleted && this.pager.appendedOnLoad === false) {
            this.clearData();
        }
    };
    List.prototype.tryCleanItemsOnReload = function (requestCompleted) {
        if (this.keepRecordsOnLoad === requestCompleted) {
            this.clearData();
        }
    };
    List.prototype.beginRequest = function () {
        this.statusInternal = operation_status_1.OperationStatus.Progress;
        var requestState = this.filtersService.getRequestState();
        return this.fetchMethod(requestState);
    };
    List.prototype.responseHasStatus = function (response) {
        return (response.status !== null &&
            typeof response.status !== 'undefined');
    };
    /**
     * Global settings of list..
     *
     * These settings are static and their values are copied to the properties of the same name for each instance of {@link List} type.
     *
     * So, changing of this settings will affect all instances of {@link List} type that will be created after such changes.
     * If you want to change settings of concrete object you can use it the same name properties.
     */
    // tslint:disable-next-line: typedef
    List.settings = {
        /**
         * @see {@link List.keepRecordsOnLoad}
         */
        keepRecordsOnLoad: false
    };
    return List;
}());
exports.List = List;
//# sourceMappingURL=list.js.map