import { Directive, ElementRef, Input, Renderer2, HostListener, NgModule, Injectable, EventEmitter, Output, SkipSelf, HostBinding, ContentChildren, Self, Inject, InjectionToken, Optional, Component, KeyValueDiffers, Pipe, IterableDiffers } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FiltersService, DefaultSelectionService, SelectionEventsHelper, AsyncSubscriber, BufferedPager, List, PagedPager, SortingsService, StateService, OperationStatus, SortDirection } from 'e2e4';
export { cloneAsLiteral, coerceValue, destroyAll, coerceTypes, OperationStatus, SortDirection, PushBasedSubscriptionProxy, PromiseSubscriptionProxy, AsyncSubscriber, BufferedPager, getDefaultFilterConfig, filter, DefaultFilterConfig, FiltersService, List, PagedPager, KeyCodes, MouseButtons, SelectionEventsHelper, DefaultSelectionService, NullObjectPager, Operation, SortingsService, StateService, StatusTrackingService } from 'e2e4';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var FocusOnRenderDirective = /** @class */ (function () {
    function FocusOnRenderDirective(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    FocusOnRenderDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // we need set timeout for the cases when element itself is rendered by *ngIf directive and we need to wait it's rendering
        setTimeout(function () { return _this.elementRef.nativeElement.focus(); }, 0);
    };
    FocusOnRenderDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[rtFocusOnRender]'
                },] },
    ];
    /** @nocollapse */
    FocusOnRenderDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return FocusOnRenderDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
EventsAttacherBase = /** @class */ (function () {
    function EventsAttacherBase(elementRef, renderer, eventListener) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.eventListener = eventListener;
        this.eventListeners = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    EventsAttacherBase.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.eventNames) {
            this.removeListeners();
            this.addListeners(this.adjustEvents(changes.eventNames.currentValue));
        }
    };
    /**
     * @return {?}
     */
    EventsAttacherBase.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeListeners();
    };
    /**
     * @param {?} eventsNames
     * @return {?}
     */
    EventsAttacherBase.prototype.adjustEvents = /**
     * @param {?} eventsNames
     * @return {?}
     */
    function (eventsNames) {
        return eventsNames ? (Array.isArray(eventsNames) ? eventsNames : [eventsNames]) : [];
    };
    /**
     * @return {?}
     */
    EventsAttacherBase.prototype.removeListeners = /**
     * @return {?}
     */
    function () {
        this.eventListeners.forEach(function (listener) {
            if (typeof listener === 'function') {
                listener();
            }
        });
        this.eventListeners = [];
    };
    /**
     * @param {?} eventNames
     * @return {?}
     */
    EventsAttacherBase.prototype.addListeners = /**
     * @param {?} eventNames
     * @return {?}
     */
    function (eventNames) {
        var _this = this;
        if (!eventNames || !eventNames.length) {
            return;
        }
        this.eventListeners = eventNames.map(function (eventName) {
            return _this.renderer.listen(_this.elementRef.nativeElement, eventName, _this.eventListener);
        });
    };
    return EventsAttacherBase;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PreventDefaultsDirective = /** @class */ (function (_super) {
    __extends(PreventDefaultsDirective, _super);
    function PreventDefaultsDirective(elementRef, renderer) {
        return _super.call(this, elementRef, renderer, function (evt) {
            evt.preventDefault();
        }) || this;
    }
    PreventDefaultsDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[rtPreventDefaults]'
                },] },
    ];
    /** @nocollapse */
    PreventDefaultsDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    PreventDefaultsDirective.propDecorators = {
        eventNames: [{ type: Input, args: ['rtPreventDefaults',] }]
    };
    return PreventDefaultsDirective;
}(EventsAttacherBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SelectOnFocusDirective = /** @class */ (function () {
    function SelectOnFocusDirective(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    SelectOnFocusDirective.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this.elementRef.nativeElement.select([]);
    };
    SelectOnFocusDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[rtSelectOnFocus]'
                },] },
    ];
    /** @nocollapse */
    SelectOnFocusDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    SelectOnFocusDirective.propDecorators = {
        onFocus: [{ type: HostListener, args: ['focus',] }]
    };
    return SelectOnFocusDirective;
}());

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StopEventsDirective = /** @class */ (function (_super) {
    __extends$1(StopEventsDirective, _super);
    function StopEventsDirective(elementRef, renderer) {
        return _super.call(this, elementRef, renderer, function (evt) {
            evt.stopPropagation();
        }) || this;
    }
    StopEventsDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[rtStopEvents]'
                },] },
    ];
    /** @nocollapse */
    StopEventsDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    StopEventsDirective.propDecorators = {
        eventNames: [{ type: Input, args: ['rtStopEvents',] }]
    };
    return StopEventsDirective;
}(EventsAttacherBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var RTMiscModule = /** @class */ (function () {
    function RTMiscModule() {
    }
    RTMiscModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [FocusOnRenderDirective, SelectOnFocusDirective, StopEventsDirective, PreventDefaultsDirective],
                    exports: [FocusOnRenderDirective, SelectOnFocusDirective, StopEventsDirective, PreventDefaultsDirective],
                    imports: [CommonModule]
                },] },
    ];
    return RTMiscModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var RegisterAsFilterDirective = /** @class */ (function () {
    function RegisterAsFilterDirective(filtersService) {
        this.filtersService = filtersService;
    }
    /**
     * @return {?}
     */
    RegisterAsFilterDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.filtersService.registerFilterTarget(this.filterTarget);
    };
    /**
     * @return {?}
     */
    RegisterAsFilterDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.filtersService.removeFilterTarget(this.filterTarget);
    };
    RegisterAsFilterDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[rtRegisterAsFilter]'
                },] },
    ];
    /** @nocollapse */
    RegisterAsFilterDirective.ctorParameters = function () { return [
        { type: FiltersService }
    ]; };
    RegisterAsFilterDirective.propDecorators = {
        filterTarget: [{ type: Input, args: ['rtRegisterAsFilter',] }]
    };
    return RegisterAsFilterDirective;
}());

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RTFiltersService = /** @class */ (function (_super) {
    __extends$2(RTFiltersService, _super);
    function RTFiltersService() {
        return _super.call(this) || this;
    }
    RTFiltersService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    RTFiltersService.ctorParameters = function () { return []; };
    return RTFiltersService;
}(FiltersService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var RTFiltersModule = /** @class */ (function () {
    function RTFiltersModule() {
    }
    RTFiltersModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [RegisterAsFilterDirective],
                    exports: [RegisterAsFilterDirective],
                    imports: [CommonModule]
                },] },
    ];
    return RTFiltersModule;
}());

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RTSelectionService = /** @class */ (function (_super) {
    __extends$3(RTSelectionService, _super);
    function RTSelectionService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.eventEmitters = new Array();
        _this.childSelectionServices = new Array();
        return _this;
    }
    /**
     * @return {?}
     */
    RTSelectionService.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.areaEventsEmitter = null;
        this.eventEmitters.length = 0;
        _super.prototype.destroy.call(this);
    };
    /**
     * @param {?=} recursive
     * @return {?}
     */
    RTSelectionService.prototype.selectAll = /**
     * @param {?=} recursive
     * @return {?}
     */
    function (recursive) {
        var _this = this;
        if (recursive === void 0) { recursive = true; }
        _super.prototype.selectAll.call(this);
        // run this directly after render to give child selectionAreas ability to render
        setTimeout(function () {
            if (recursive && _this.childSelectionServices) {
                _this.childSelectionServices.forEach(function (service) {
                    service.selectAll(recursive);
                });
            }
        }, 0);
    };
    /**
     * @param {?=} recursive
     * @return {?}
     */
    RTSelectionService.prototype.deselectAll = /**
     * @param {?=} recursive
     * @return {?}
     */
    function (recursive) {
        if (recursive === void 0) { recursive = true; }
        if (recursive && this.childSelectionServices) {
            this.childSelectionServices.forEach(function (service) {
                service.deselectAll(recursive);
            });
        }
        _super.prototype.deselectAll.call(this);
    };
    /**
     * @param {?} tuple
     * @param {?} selected
     * @return {?}
     */
    RTSelectionService.prototype.processSelection = /**
     * @param {?} tuple
     * @param {?} selected
     * @return {?}
     */
    function (tuple, selected) {
        /** @type {?} */
        var initialSelectState = this.eventEmitters[tuple.index]
            ? this.eventEmitters[tuple.index].selected || null
            : null;
        if (initialSelectState === null || initialSelectState !== selected) {
            if (this.eventEmitters.length > tuple.index && this.eventEmitters[tuple.index]) {
                this.emitEvents(this.eventEmitters[tuple.index], selected, tuple);
                this.eventEmitters[tuple.index].postProcessSelection(selected);
            }
            if (this.areaEventsEmitter) {
                this.emitEvents(this.areaEventsEmitter, selected, tuple);
            }
        }
    };
    /**
     * @param {?} emitter
     * @param {?} selected
     * @param {?} tuple
     * @return {?}
     */
    RTSelectionService.prototype.emitEvents = /**
     * @param {?} emitter
     * @param {?} selected
     * @param {?} tuple
     * @return {?}
     */
    function (emitter, selected, tuple) {
        if (selected) {
            emitter.itemSelected.emit({ index: tuple.index, item: tuple.item });
        }
        else {
            emitter.itemDeselected.emit({ index: tuple.index, item: tuple.item });
        }
        emitter.selectionChanged.emit({ index: tuple.index, item: tuple.item });
    };
    return RTSelectionService;
}(DefaultSelectionService));

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RTSelectionEventsHelper = /** @class */ (function (_super) {
    __extends$4(RTSelectionEventsHelper, _super);
    function RTSelectionEventsHelper(selectionService) {
        var _this = _super.call(this, selectionService) || this;
        _this.preventEventsDefaults = true;
        _this.stopEventsPropagation = true;
        _this.multiple = true;
        return _this;
    }
    RTSelectionEventsHelper.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    RTSelectionEventsHelper.ctorParameters = function () { return [
        { type: RTSelectionService }
    ]; };
    return RTSelectionEventsHelper;
}(SelectionEventsHelper));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SelectableDirective = /** @class */ (function () {
    function SelectableDirective(selectionEventsHelper, renderer, el) {
        this.selectionEventsHelper = selectionEventsHelper;
        this.renderer = renderer;
        this.el = el;
        this.index = null;
        /* tslint:disable-next-line:no-input-rename */
        this.item = null;
        this.selectedChange = new EventEmitter();
        this.itemSelected = new EventEmitter();
        this.itemDeselected = new EventEmitter();
        this.selectionChanged = new EventEmitter();
        this.selectedInternal = false;
    }
    Object.defineProperty(SelectableDirective.prototype, "selected", {
        get: /**
         * @return {?}
         */
        function () {
            return this.selectedInternal;
        },
        set: /**
         * @param {?} selected
         * @return {?}
         */
        function (selected) {
            if (selected) {
                this.selectionEventsHelper.selectionService.selectIndex(this.index, this.selectionEventsHelper.multiple);
            }
            else {
                this.selectionEventsHelper.selectionService.deselectIndex(this.index);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} ctrlKeyPressed
     * @param {?} shiftKeyPressed
     * @param {?} mouseButton
     * @param {?} preventDefaultFn
     * @param {?} stopPropagationFn
     * @param {?} executionContext
     * @return {?}
     */
    SelectableDirective.prototype.mouseUpHandler = /**
     * @param {?} ctrlKeyPressed
     * @param {?} shiftKeyPressed
     * @param {?} mouseButton
     * @param {?} preventDefaultFn
     * @param {?} stopPropagationFn
     * @param {?} executionContext
     * @return {?}
     */
    function (ctrlKeyPressed, shiftKeyPressed, mouseButton, preventDefaultFn, stopPropagationFn, executionContext) {
        if (this.selectionEventsHelper.mouseHandler(ctrlKeyPressed, shiftKeyPressed, mouseButton, this.index)) {
            this.clearWindowSelection();
            if (this.selectionEventsHelper.preventEventsDefaults && preventDefaultFn) {
                preventDefaultFn.call(executionContext);
            }
            if (this.selectionEventsHelper.stopEventsPropagation && stopPropagationFn) {
                stopPropagationFn.call(executionContext);
            }
        }
    };
    /**
     * @param {?} selected
     * @return {?}
     */
    SelectableDirective.prototype.postProcessSelection = /**
     * @param {?} selected
     * @return {?}
     */
    function (selected) {
        if (selected === this.selected) {
            return;
        }
        this.selectedInternal = selected;
        this.selectedChange.emit(this.selectedInternal);
        if (SelectableDirective.settings.selectedClassName) {
            if (this.selected) {
                this.renderer.addClass(this.el.nativeElement, SelectableDirective.settings.selectedClassName);
            }
            else {
                this.renderer.removeClass(this.el.nativeElement, SelectableDirective.settings.selectedClassName);
            }
        }
    };
    /**
     * @return {?}
     */
    SelectableDirective.prototype.clearWindowSelection = /**
     * @return {?}
     */
    function () {
        try {
            window.getSelection().removeAllRanges();
        }
        catch (e) {
            // do nothing
        }
    };
    SelectableDirective.settings = {
        selectedClassName: 'rt-selected'
    };
    SelectableDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'rtSelectable',
                    selector: '[rtSelectable]'
                },] },
    ];
    /** @nocollapse */
    SelectableDirective.ctorParameters = function () { return [
        { type: RTSelectionEventsHelper, decorators: [{ type: SkipSelf }] },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    SelectableDirective.propDecorators = {
        item: [{ type: Input, args: ['rtSelectable',] }],
        selectedChange: [{ type: Output }],
        itemSelected: [{ type: Output }],
        itemDeselected: [{ type: Output }],
        selectionChanged: [{ type: Output }],
        selected: [{ type: Input }],
        mouseUpHandler: [{ type: HostListener, args: ['mouseup', [
                        '$event.ctrlKey',
                        '$event.shiftKey',
                        '$event.which',
                        '$event.preventDefault',
                        '$event.stopPropagation',
                        '$event'
                    ],] }]
    };
    return SelectableDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SelectionCheckboxForDirective = /** @class */ (function () {
    function SelectionCheckboxForDirective(selectionEventsHelper, selectionService) {
        this.selectionEventsHelper = selectionEventsHelper;
        this.selectionService = selectionService;
        this.index = null;
        /* tslint:disable-next-line:no-input-rename */
        this.item = null;
        this.selectedChange = new EventEmitter();
        this.itemSelected = new EventEmitter();
        this.itemDeselected = new EventEmitter();
        this.selectionChanged = new EventEmitter();
        this.selectedInternal = false;
    }
    Object.defineProperty(SelectionCheckboxForDirective.prototype, "selected", {
        get: /**
         * @return {?}
         */
        function () {
            return this.selectedInternal;
        },
        set: /**
         * @param {?} selected
         * @return {?}
         */
        function (selected) {
            if (selected) {
                this.selectionService.selectIndex(this.index, this.selectionEventsHelper.multiple);
            }
            else {
                this.selectionService.deselectIndex(this.index);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCheckboxForDirective.prototype, "isChecked", {
        get: /**
         * @return {?}
         */
        function () {
            return this.selectionService.isIndexSelected(this.index);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} isChecked
     * @return {?}
     */
    SelectionCheckboxForDirective.prototype.changeHandler = /**
     * @param {?} isChecked
     * @return {?}
     */
    function (isChecked) {
        if (isChecked) {
            this.selectionService.selectIndex(this.index, this.selectionEventsHelper.multiple);
        }
        else {
            this.selectionService.deselectIndex(this.index);
        }
    };
    /**
     * @param {?} selected
     * @return {?}
     */
    SelectionCheckboxForDirective.prototype.postProcessSelection = /**
     * @param {?} selected
     * @return {?}
     */
    function (selected) {
        if (selected === this.selected) {
            return;
        }
        this.selectedInternal = selected;
        this.selectedChange.emit(this.selectedInternal);
    };
    SelectionCheckboxForDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'rtSelectionCheckboxFor',
                    /* tslint:disable-next-line:directive-selector */
                    selector: 'input[rtSelectionCheckboxFor]'
                },] },
    ];
    /** @nocollapse */
    SelectionCheckboxForDirective.ctorParameters = function () { return [
        { type: RTSelectionEventsHelper, decorators: [{ type: SkipSelf }] },
        { type: RTSelectionService, decorators: [{ type: SkipSelf }] }
    ]; };
    SelectionCheckboxForDirective.propDecorators = {
        item: [{ type: Input, args: ['rtSelectionCheckboxFor',] }],
        selected: [{ type: Input }],
        selectedChange: [{ type: Output }],
        itemSelected: [{ type: Output }],
        itemDeselected: [{ type: Output }],
        selectionChanged: [{ type: Output }],
        isChecked: [{ type: HostBinding, args: ['checked',] }],
        changeHandler: [{ type: HostListener, args: ['change', ['$event.target.checked'],] }]
    };
    return SelectionCheckboxForDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SelectionAreaDirective = /** @class */ (function () {
    function SelectionAreaDirective(selectionService, selectionEventsHelper) {
        this.selectionService = selectionService;
        this.selectionEventsHelper = selectionEventsHelper;
        this.tabIndex = 0;
        this.autoSelectFirst = false;
        this.itemSelected = new EventEmitter();
        this.itemDeselected = new EventEmitter();
        this.selectionChanged = new EventEmitter();
        this.selectionService.areaEventsEmitter = this;
        this.selectionEventsHelper = selectionEventsHelper;
    }
    Object.defineProperty(SelectionAreaDirective.prototype, "preventEventsDefaults", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.selectionEventsHelper.preventEventsDefaults = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionAreaDirective.prototype, "stopEventsPropagation", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.selectionEventsHelper.stopEventsPropagation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionAreaDirective.prototype, "horizontal", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.selectionEventsHelper.horizontal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionAreaDirective.prototype, "multiple", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.selectionEventsHelper.multiple = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionAreaDirective.prototype, "toggleOnly", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.selectionEventsHelper.toggleOnly = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionAreaDirective.prototype, "trackBy", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value !== 'function') {
                throw new Error('trackBy parameter value must be a function');
            }
            this.selectionService.trackByFn = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SelectionAreaDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.itemsSubscription.unsubscribe();
        this.checkboxesSubscription.unsubscribe();
        this.childSelectionAreasSubscription.unsubscribe();
        this.selectionService.deselectAll();
        this.selectionService.destroy();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SelectionAreaDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        if (false === this.selectionService.hasSelections() &&
            changes.autoSelectFirst &&
            changes.autoSelectFirst.currentValue === true) {
            this.selectionService.selectIndex(0, false);
        }
        if (changes.multiple && changes.multiple.currentValue === false) {
            /** @type {?} */
            var selectedIndexes = this.selectionService.getSelectedIndexes();
            if (selectedIndexes.length > 1) {
                selectedIndexes.splice(0, 1);
                selectedIndexes.forEach(function (index) {
                    _this.selectionService.deselectIndex(index);
                });
            }
        }
    };
    /**
     * @param {?} ctrlKeyPressed
     * @param {?} shiftKeyPressed
     * @param {?} keyCode
     * @param {?} preventDefaultFn
     * @param {?} stopPropagationFn
     * @param {?} executionContext
     * @return {?}
     */
    SelectionAreaDirective.prototype.keyDownHandler = /**
     * @param {?} ctrlKeyPressed
     * @param {?} shiftKeyPressed
     * @param {?} keyCode
     * @param {?} preventDefaultFn
     * @param {?} stopPropagationFn
     * @param {?} executionContext
     * @return {?}
     */
    function (ctrlKeyPressed, shiftKeyPressed, keyCode, preventDefaultFn, stopPropagationFn, executionContext) {
        if (this.selectionEventsHelper.keyboardHandler(ctrlKeyPressed, shiftKeyPressed, keyCode)) {
            if (this.selectionEventsHelper.preventEventsDefaults && preventDefaultFn) {
                preventDefaultFn.call(executionContext);
            }
            if (this.selectionEventsHelper.stopEventsPropagation && stopPropagationFn) {
                stopPropagationFn.call(executionContext);
            }
        }
    };
    /**
     * @return {?}
     */
    SelectionAreaDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.selectableItems.length > 0) {
            this.buildSelectionSource(this.selectableItems);
        }
        if (this.childSelectionCheckboxes.length > 0) {
            this.buildSelectionSource(this.childSelectionCheckboxes);
        }
        this.buildSelectionServicesList(this.childSelectionAreas);
        this.itemsSubscription = this.selectableItems.changes.subscribe(this.buildSelectionSource.bind(this));
        this.checkboxesSubscription = this.childSelectionCheckboxes.changes.subscribe(this.buildSelectionSource.bind(this));
        this.childSelectionAreasSubscription = this.childSelectionAreas.changes.subscribe(this.buildSelectionServicesList.bind(this));
    };
    /**
     * @param {?} items
     * @return {?}
     */
    SelectionAreaDirective.prototype.buildSelectionSource = /**
     * @param {?} items
     * @return {?}
     */
    function (items) {
        var _this = this;
        /** @type {?} */
        var index = 0;
        this.selectionService.eventEmitters = items.map(function (item) {
            item.index = index++;
            return item;
        });
        this.selectionService.items = items.map(function (item) { return item.item; });
        if (this.selectionService.items.length > 0) {
            setTimeout(function () {
                // since we've modify collection on first render, to prevent error 'Expression has changed after it was checked' we've do selection after render
                if (_this.selectionService.items.length > 0) {
                    _this.selectionService.checkSelection();
                    // repeats first element selection since checking can deselect all elements
                    if (false === _this.selectionService.hasSelections() && _this.autoSelectFirst) {
                        _this.selectionService.selectIndex(0, false);
                    }
                }
            }, 0);
        }
    };
    /**
     * @param {?} items
     * @return {?}
     */
    SelectionAreaDirective.prototype.buildSelectionServicesList = /**
     * @param {?} items
     * @return {?}
     */
    function (items) {
        var _this = this;
        this.selectionService.childSelectionServices = items
            .filter(function (area) { return area !== _this; })
            .map(function (area) { return area.selectionService; });
    };
    SelectionAreaDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'rtSelectionArea',
                    providers: [RTSelectionService, RTSelectionEventsHelper],
                    selector: '[rtSelectionArea]'
                },] },
    ];
    /** @nocollapse */
    SelectionAreaDirective.ctorParameters = function () { return [
        { type: RTSelectionService, decorators: [{ type: Self }] },
        { type: RTSelectionEventsHelper, decorators: [{ type: Self }] }
    ]; };
    SelectionAreaDirective.propDecorators = {
        selectableItems: [{ type: ContentChildren, args: [SelectableDirective, { descendants: false },] }],
        childSelectionCheckboxes: [{ type: ContentChildren, args: [SelectionCheckboxForDirective, { descendants: false },] }],
        childSelectionAreas: [{ type: ContentChildren, args: [SelectionAreaDirective, { descendants: false },] }],
        tabIndex: [{ type: HostBinding, args: ['tabIndex',] }],
        preventEventsDefaults: [{ type: Input }],
        stopEventsPropagation: [{ type: Input }],
        horizontal: [{ type: Input }],
        multiple: [{ type: Input }],
        toggleOnly: [{ type: Input }],
        autoSelectFirst: [{ type: Input }],
        trackBy: [{ type: Input }],
        itemSelected: [{ type: Output }],
        itemDeselected: [{ type: Output }],
        selectionChanged: [{ type: Output }],
        keyDownHandler: [{ type: HostListener, args: ['keydown', [
                        '$event.ctrlKey',
                        '$event.shiftKey',
                        '$event.keyCode',
                        '$event.preventDefault',
                        '$event.stopPropagation',
                        '$event'
                    ],] }]
    };
    return SelectionAreaDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var RTSelectionModule = /** @class */ (function () {
    function RTSelectionModule() {
    }
    RTSelectionModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [SelectableDirective, SelectionAreaDirective, SelectionCheckboxForDirective],
                    exports: [SelectableDirective, SelectionAreaDirective, SelectionCheckboxForDirective],
                    imports: [CommonModule]
                },] },
    ];
    return RTSelectionModule;
}());

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/** @type {?} */
var RTFilterTarget = new InjectionToken('RTFilterTarget');
/**
 * @abstract
 */
var  /**
 * @abstract
 */
RTStateService = /** @class */ (function (_super) {
    __extends$5(RTStateService, _super);
    function RTStateService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RTStateService;
}(StateService));
var RTOperationStatus = /** @class */ (function () {
    function RTOperationStatus() {
    }
    return RTOperationStatus;
}());
var RTList = /** @class */ (function (_super) {
    __extends$5(RTList, _super);
    function RTList(asyncSubscriber, stateServices, filterTargets, sortingsService, filtersService) {
        var _a;
        var _this = _super.call(this, asyncSubscriber, stateServices, sortingsService, filtersService) || this;
        _this.loadStarted = new EventEmitter();
        _this.loadSucceed = new EventEmitter();
        _this.loadFailed = new EventEmitter();
        _this.filterTargets = [];
        if (filterTargets != null) {
            if (Array.isArray(filterTargets)) {
                (_a = _this.filterTargets).push.apply(_a, filterTargets);
            }
            else {
                _this.filterTargets.push(filterTargets);
            }
        }
        return _this;
    }
    /**
     * @param {?} response
     * @return {?}
     */
    RTList.prototype.loadSuccessCallback = /**
     * @param {?} response
     * @return {?}
     */
    function (response) {
        /** @type {?} */
        var result = _super.prototype.loadSuccessCallback.call(this, response);
        this.loadSucceed.emit(result);
        return result;
    };
    /**
     * @return {?}
     */
    RTList.prototype.loadFailCallback = /**
     * @return {?}
     */
    function () {
        _super.prototype.loadFailCallback.call(this);
        this.loadFailed.emit();
    };
    /**
     * @return {?}
     */
    RTList.prototype.loadData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var subscribable = _super.prototype.loadData.call(this);
        this.loadStarted.emit();
        return subscribable;
    };
    /**
     * @return {?}
     */
    RTList.prototype.reloadData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var subscribable = _super.prototype.reloadData.call(this);
        this.loadStarted.emit();
        return subscribable;
    };
    /**
     * @return {?}
     */
    RTList.prototype.init = /**
     * @return {?}
     */
    function () {
        var _a;
        (_a = this.filtersService).registerFilterTarget.apply(_a, this.filterTargets);
        _super.prototype.init.call(this);
    };
    RTList.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    RTList.ctorParameters = function () { return [
        { type: AsyncSubscriber },
        { type: RTStateService, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [RTFilterTarget,] }] },
        { type: SortingsService },
        { type: FiltersService }
    ]; };
    return RTList;
}(List));
var RTPagedPager = /** @class */ (function (_super) {
    __extends$5(RTPagedPager, _super);
    function RTPagedPager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RTPagedPager.decorators = [
        { type: Injectable },
    ];
    return RTPagedPager;
}(PagedPager));
var RTBufferedPager = /** @class */ (function (_super) {
    __extends$5(RTBufferedPager, _super);
    function RTBufferedPager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RTBufferedPager.decorators = [
        { type: Injectable },
    ];
    return RTBufferedPager;
}(BufferedPager));
var RTSortingsService = /** @class */ (function (_super) {
    __extends$5(RTSortingsService, _super);
    function RTSortingsService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RTSortingsService.decorators = [
        { type: Injectable },
    ];
    return RTSortingsService;
}(SortingsService));
/** @type {?} */
var LIST_PROVIDERS = [
    AsyncSubscriber,
    RTList,
    { provide: FiltersService, useClass: RTFiltersService },
    { provide: RTOperationStatus, useExisting: RTList },
    { provide: SortingsService, useClass: RTSortingsService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ListDirective = /** @class */ (function () {
    function ListDirective(listService, sortingsService) {
        var _this = this;
        this.listService = listService;
        this.sortingsService = sortingsService;
        this.listInit = new EventEmitter(false);
        this.afterListInit = new EventEmitter(false);
        this.loadSucceed = new EventEmitter();
        this.loadFailed = new EventEmitter();
        this.loadStarted = new EventEmitter();
        this.loadOnInit = true;
        this.keepRecordsOnLoad = false;
        this.successSubscription = listService.loadSucceed.subscribe(function (response) {
            _this.loadSucceed.emit(response);
        });
        this.failSubscription = listService.loadFailed.subscribe(function () {
            _this.loadFailed.emit();
        });
        this.loadStartedSubscription = listService.loadStarted.subscribe(function () {
            _this.loadStarted.emit();
        });
    }
    Object.defineProperty(ListDirective.prototype, "fetchMethod", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.listService.fetchMethod = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ListDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // We call init in ngAfterViewInit to:
        // 1. allow all child controls to be applied to markup and regiter themself in filtersService
        // 2. give ability to all child controls to apply their default values
        // 3. overwrite theese default values by values passed via persistence services
        // 4. execute all ngAfterViewInit for custom services registration (setTimeout)
        setTimeout(function () {
            _this.listInit.emit(_this.listService);
            _this.listService.init();
            _this.afterListInit.emit(_this.listService);
            if (_this.loadOnInit) {
                _this.listService.loadData();
            }
        }, 0);
    };
    /**
     * @return {?}
     */
    ListDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.listService.destroy();
        this.successSubscription.unsubscribe();
        this.failSubscription.unsubscribe();
        this.loadStartedSubscription.unsubscribe();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ListDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.defaultSortings) {
            this.sortingsService.defaultSortings = changes.defaultSortings.currentValue;
        }
        if (changes.keepRecordsOnLoad) {
            this.listService.keepRecordsOnLoad = changes.keepRecordsOnLoad.currentValue;
        }
    };
    /**
     * @return {?}
     */
    ListDirective.prototype.reloadData = /**
     * @return {?}
     */
    function () {
        return this.listService.reloadData();
    };
    /**
     * @return {?}
     */
    ListDirective.prototype.loadData = /**
     * @return {?}
     */
    function () {
        return this.listService.loadData();
    };
    /**
     * @return {?}
     */
    ListDirective.prototype.resetSettings = /**
     * @return {?}
     */
    function () {
        this.listService.resetSettings();
    };
    /**
     * @return {?}
     */
    ListDirective.prototype.cancelRequests = /**
     * @return {?}
     */
    function () {
        this.listService.cancelRequests();
    };
    Object.defineProperty(ListDirective.prototype, "items", {
        get: /**
         * @return {?}
         */
        function () {
            return this.listService.items;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListDirective.prototype, "busy", {
        get: /**
         * @return {?}
         */
        function () {
            return this.listService.busy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListDirective.prototype, "ready", {
        get: /**
         * @return {?}
         */
        function () {
            return this.listService.ready;
        },
        enumerable: true,
        configurable: true
    });
    ListDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'rtList',
                    providers: [LIST_PROVIDERS],
                    selector: '[rtList]'
                },] },
    ];
    /** @nocollapse */
    ListDirective.ctorParameters = function () { return [
        { type: RTList, decorators: [{ type: Self }] },
        { type: SortingsService, decorators: [{ type: Self }] }
    ]; };
    ListDirective.propDecorators = {
        listInit: [{ type: Output }],
        afterListInit: [{ type: Output }],
        loadSucceed: [{ type: Output }],
        loadFailed: [{ type: Output }],
        loadStarted: [{ type: Output }],
        defaultSortings: [{ type: Input }],
        loadOnInit: [{ type: Input }],
        keepRecordsOnLoad: [{ type: Input }],
        fetchMethod: [{ type: Input, args: ['rtList',] }]
    };
    return ListDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
StatusComponentBase = /** @class */ (function () {
    function StatusComponentBase(trackedStatusObject, differs, visibleState) {
        var _this = this;
        this.trackedStatusObject = trackedStatusObject;
        this.checkStateFieldChanges = function (item) {
            if (item.key === 'status' || item.key === 'statusInternal') {
                _this.setVisibility();
            }
        };
        this.visibleState = visibleState;
        this.listDiffer = differs.find([]).create();
    }
    /**
     * @return {?}
     */
    StatusComponentBase.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.setVisibility();
    };
    /**
     * @return {?}
     */
    StatusComponentBase.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var stateDiff = this.listDiffer.diff(this.trackedStatusObject);
        if (stateDiff) {
            stateDiff.forEachChangedItem(this.checkStateFieldChanges);
        }
    };
    /**
     * @return {?}
     */
    StatusComponentBase.prototype.setVisibility = /**
     * @return {?}
     */
    function () {
        this.isVisible = this.trackedStatusObject.status === this.visibleState;
    };
    return StatusComponentBase;
}());

var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StatusDoneComponent = /** @class */ (function (_super) {
    __extends$6(StatusDoneComponent, _super);
    function StatusDoneComponent(trackedStatusObject, differs) {
        return _super.call(this, trackedStatusObject, differs, OperationStatus.Done) || this;
    }
    StatusDoneComponent.decorators = [
        { type: Component, args: [{
                    selector: 'rt-status-done',
                    template: "<ng-content *ngIf=\"isVisible\"></ng-content>"
                },] },
    ];
    /** @nocollapse */
    StatusDoneComponent.ctorParameters = function () { return [
        { type: RTOperationStatus },
        { type: KeyValueDiffers }
    ]; };
    return StatusDoneComponent;
}(StatusComponentBase));

var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StatusFailedComponent = /** @class */ (function (_super) {
    __extends$7(StatusFailedComponent, _super);
    function StatusFailedComponent(trackedStatusObject, differs) {
        return _super.call(this, trackedStatusObject, differs, OperationStatus.Fail) || this;
    }
    StatusFailedComponent.decorators = [
        { type: Component, args: [{
                    selector: 'rt-status-failed',
                    template: "<ng-content *ngIf=\"isVisible\"></ng-content>"
                },] },
    ];
    /** @nocollapse */
    StatusFailedComponent.ctorParameters = function () { return [
        { type: RTOperationStatus },
        { type: KeyValueDiffers }
    ]; };
    return StatusFailedComponent;
}(StatusComponentBase));

var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StatusInProgressComponent = /** @class */ (function (_super) {
    __extends$8(StatusInProgressComponent, _super);
    function StatusInProgressComponent(trackedStatusObject, differs) {
        return _super.call(this, trackedStatusObject, differs, OperationStatus.Progress) || this;
    }
    StatusInProgressComponent.decorators = [
        { type: Component, args: [{
                    selector: 'rt-status-progress',
                    template: "<ng-content *ngIf=\"isVisible\"></ng-content>"
                },] },
    ];
    /** @nocollapse */
    StatusInProgressComponent.ctorParameters = function () { return [
        { type: RTOperationStatus },
        { type: KeyValueDiffers }
    ]; };
    return StatusInProgressComponent;
}(StatusComponentBase));

var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StatusInitialComponent = /** @class */ (function (_super) {
    __extends$9(StatusInitialComponent, _super);
    function StatusInitialComponent(trackedStatusObject, differs) {
        return _super.call(this, trackedStatusObject, differs, OperationStatus.Initial) || this;
    }
    StatusInitialComponent.decorators = [
        { type: Component, args: [{
                    selector: 'rt-status-initial',
                    template: "<ng-content *ngIf=\"isVisible\"></ng-content>"
                },] },
    ];
    /** @nocollapse */
    StatusInitialComponent.ctorParameters = function () { return [
        { type: RTOperationStatus },
        { type: KeyValueDiffers }
    ]; };
    return StatusInitialComponent;
}(StatusComponentBase));

var __extends$a = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StatusNoDataComponent = /** @class */ (function (_super) {
    __extends$a(StatusNoDataComponent, _super);
    function StatusNoDataComponent(trackedStatusObject, differs) {
        return _super.call(this, trackedStatusObject, differs, OperationStatus.NoData) || this;
    }
    StatusNoDataComponent.decorators = [
        { type: Component, args: [{
                    selector: 'rt-status-no-data',
                    template: "<ng-content *ngIf=\"isVisible\"></ng-content>"
                },] },
    ];
    /** @nocollapse */
    StatusNoDataComponent.ctorParameters = function () { return [
        { type: RTOperationStatus },
        { type: KeyValueDiffers }
    ]; };
    return StatusNoDataComponent;
}(StatusComponentBase));

var __extends$b = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StatusRequestCancelledComponent = /** @class */ (function (_super) {
    __extends$b(StatusRequestCancelledComponent, _super);
    function StatusRequestCancelledComponent(trackedStatusObject, differs) {
        return _super.call(this, trackedStatusObject, differs, OperationStatus.Cancelled) || this;
    }
    StatusRequestCancelledComponent.decorators = [
        { type: Component, args: [{
                    selector: 'rt-status-request-cancelled',
                    template: "<ng-content *ngIf=\"isVisible\"></ng-content>"
                },] },
    ];
    /** @nocollapse */
    StatusRequestCancelledComponent.ctorParameters = function () { return [
        { type: RTOperationStatus },
        { type: KeyValueDiffers }
    ]; };
    return StatusRequestCancelledComponent;
}(StatusComponentBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var RowNumberPipe = /** @class */ (function () {
    function RowNumberPipe() {
    }
    /**
     * @param {?} index
     * @param {?} rtList
     * @return {?}
     */
    RowNumberPipe.prototype.transform = /**
     * @param {?} index
     * @param {?} rtList
     * @return {?}
     */
    function (index, rtList) {
        if (index !== 0 && (!index || isNaN(index))) {
            throw new Error('Invalid input value for rtRowNumber pipe. Must be a valid numeric value.');
        }
        if (!rtList) {
            throw new Error('Invalid value provided for parameter "rtList" of rtRowNumber pipe . Must be "rtList" directive instance.');
        }
        if (rtList.listService.pager !== null && (/** @type {?} */ (rtList.listService.pager)).displayFrom) {
            return index + (/** @type {?} */ (rtList.listService.pager)).displayFrom;
        }
        else {
            return index + 1;
        }
    };
    RowNumberPipe.decorators = [
        { type: Pipe, args: [{ name: 'rtRowNumber' },] },
    ];
    return RowNumberPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SortDirective = /** @class */ (function () {
    function SortDirective(listService, sortingsService, renderer, el, differs) {
        var _this = this;
        this.listService = listService;
        this.sortingsService = sortingsService;
        this.renderer = renderer;
        this.sortItemRemovedCallback = function (removedItem) {
            if (removedItem.item && removedItem.item.fieldName === _this.fieldName) {
                _this.removeSortClasses();
            }
        };
        this.sortItemAddedCallback = function (addedItem) {
            if (addedItem.item && addedItem.item.fieldName === _this.fieldName) {
                _this.setSortClasses(addedItem.item);
            }
        };
        this.sortingsDiffer = differs.find([]).create(null);
        this.nativeEl = el.nativeElement;
    }
    /**
     * @return {?}
     */
    SortDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (SortDirective.settings.sortableClassName) {
            this.renderer.addClass(this.nativeEl, SortDirective.settings.sortableClassName);
        }
        this.sortingsService.sortings.some(function (sortParameter) {
            if (sortParameter.fieldName === _this.fieldName) {
                _this.setSortClasses(sortParameter);
                return true;
            }
            return false;
        });
    };
    /**
     * @param {?} ctrlKeyPressed
     * @return {?}
     */
    SortDirective.prototype.clickHandler = /**
     * @param {?} ctrlKeyPressed
     * @return {?}
     */
    function (ctrlKeyPressed) {
        if (this.listService.ready && !this.disableSort) {
            this.sortingsService.setSort(this.fieldName, ctrlKeyPressed);
            this.listService.reloadData();
        }
    };
    /**
     * @return {?}
     */
    SortDirective.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var changes = this.sortingsDiffer.diff(this.sortingsService.sortings);
        if (changes) {
            changes.forEachRemovedItem(this.sortItemRemovedCallback);
            changes.forEachAddedItem(this.sortItemAddedCallback);
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SortDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.disableSort && changes.disableSort.currentValue) {
            this.sortingsService.removeSort(this.fieldName);
        }
    };
    /**
     * @return {?}
     */
    SortDirective.prototype.removeSortClasses = /**
     * @return {?}
     */
    function () {
        if (SortDirective.settings.sortAscClassName) {
            this.renderer.removeClass(this.nativeEl, SortDirective.settings.sortAscClassName);
        }
        if (SortDirective.settings.sortDescClassName) {
            this.renderer.removeClass(this.nativeEl, SortDirective.settings.sortDescClassName);
        }
    };
    /**
     * @param {?} sortParameter
     * @return {?}
     */
    SortDirective.prototype.setSortClasses = /**
     * @param {?} sortParameter
     * @return {?}
     */
    function (sortParameter) {
        /** @type {?} */
        var direction = sortParameter.direction;
        if (SortDirective.settings.sortAscClassName) {
            if (direction === SortDirection.Asc) {
                this.renderer.addClass(this.nativeEl, SortDirective.settings.sortAscClassName);
            }
            else {
                this.renderer.removeClass(this.nativeEl, SortDirective.settings.sortAscClassName);
            }
        }
        if (SortDirective.settings.sortDescClassName) {
            if (direction === SortDirection.Desc) {
                this.renderer.addClass(this.nativeEl, SortDirective.settings.sortDescClassName);
            }
            else {
                this.renderer.removeClass(this.nativeEl, SortDirective.settings.sortDescClassName);
            }
        }
    };
    SortDirective.settings = {
        sortAscClassName: 'rt-sort-asc',
        sortDescClassName: 'rt-sort-desc',
        sortableClassName: 'rt-sortable'
    };
    SortDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[rtSort]'
                },] },
    ];
    /** @nocollapse */
    SortDirective.ctorParameters = function () { return [
        { type: RTList, decorators: [{ type: SkipSelf }] },
        { type: SortingsService, decorators: [{ type: SkipSelf }] },
        { type: Renderer2 },
        { type: ElementRef },
        { type: IterableDiffers }
    ]; };
    SortDirective.propDecorators = {
        fieldName: [{ type: Input, args: ['rtSort',] }],
        disableSort: [{ type: Input }],
        clickHandler: [{ type: HostListener, args: ['click', ['$event.ctrlKey'],] }]
    };
    return SortDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var BufferedPagerComponent = /** @class */ (function () {
    function BufferedPagerComponent(pager, listService) {
        this.pager = pager;
        this.listService = listService;
        this.defaultRowCount = RTBufferedPager.settings.defaultRowCount;
        this.maxRowCount = RTBufferedPager.settings.maxRowCount;
        this.minRowCount = RTBufferedPager.settings.minRowCount;
        this.listService.pager = pager;
    }
    /**
     * @return {?}
     */
    BufferedPagerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.pager.takeRowCount = this.defaultRowCount * 1;
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    BufferedPagerComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.defaultRowCount) {
            this.pager.defaultRowCount = changes.defaultRowCount.currentValue * 1;
        }
        if (changes.maxRowCount) {
            this.pager.maxRowCount = changes.maxRowCount.currentValue * 1;
        }
        if (changes.minRowCount) {
            this.pager.minRowCount = changes.minRowCount.currentValue * 1;
        }
    };
    Object.defineProperty(BufferedPagerComponent.prototype, "canLoadMore", {
        get: /**
         * @return {?}
         */
        function () {
            return this.pager.canLoadMore;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BufferedPagerComponent.prototype.loadMore = /**
     * @return {?}
     */
    function () {
        if (this.canLoadMore) {
            return this.listService.loadData();
        }
        return null;
    };
    BufferedPagerComponent.decorators = [
        { type: Component, args: [{
                    providers: [{ provide: BufferedPager, useClass: RTBufferedPager }],
                    selector: 'rt-buffered-pager',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    /** @nocollapse */
    BufferedPagerComponent.ctorParameters = function () { return [
        { type: BufferedPager },
        { type: RTList }
    ]; };
    BufferedPagerComponent.propDecorators = {
        defaultRowCount: [{ type: Input }],
        maxRowCount: [{ type: Input }],
        minRowCount: [{ type: Input }]
    };
    return BufferedPagerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var InfiniteDirective = /** @class */ (function () {
    function InfiniteDirective(elementRef, bufferedPager, list, renderer) {
        this.elementRef = elementRef;
        this.bufferedPager = bufferedPager;
        this.list = list;
        this.renderer = renderer;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    InfiniteDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        if (this.scrollListener) {
            this.scrollListener();
        }
        if (changes.targetElement && changes.targetElement.currentValue) {
            this.scrollListener = this.renderer.listen(this.targetElement, 'scroll', function () {
                if (_this.list.busy || false === _this.bufferedPager.canLoadMore) {
                    return;
                }
                /** @type {?} */
                var targetTop = _this.targetElement.getBoundingClientRect().top;
                /** @type {?} */
                var targetHeight = _this.targetElement.clientHeight;
                /** @type {?} */
                var elementPosition = (/** @type {?} */ (_this.elementRef.nativeElement)).getBoundingClientRect().top;
                if (targetTop + targetHeight >= elementPosition) {
                    _this.list.loadData();
                }
            });
        }
        else {
            this.scrollListener = this.renderer.listen('window', 'scroll', function () {
                if (_this.list.busy || false === _this.bufferedPager.canLoadMore) {
                    return;
                }
                /** @type {?} */
                var windowHeight = document.documentElement.clientHeight;
                /** @type {?} */
                var elementPosition = (/** @type {?} */ (_this.elementRef.nativeElement)).getBoundingClientRect().top;
                if (elementPosition - windowHeight <= 0) {
                    _this.list.loadData();
                }
            });
        }
    };
    /**
     * @return {?}
     */
    InfiniteDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.scrollListener();
    };
    InfiniteDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[rtInfinite]'
                },] },
    ];
    /** @nocollapse */
    InfiniteDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: BufferedPager },
        { type: RTList },
        { type: Renderer2 }
    ]; };
    InfiniteDirective.propDecorators = {
        targetElement: [{ type: Input, args: ['rtInfinite',] }]
    };
    return InfiniteDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var PagerInputBase = /** @class */ (function () {
    function PagerInputBase(pager, differs, changeTrackingKey) {
        var _this = this;
        this.pager = pager;
        this.checkValueChanged = function (item) {
            if (item.key === _this.changeTrackingKey && item.currentValue !== _this.innerValue) {
                _this.innerValue = item.currentValue;
            }
        };
        this.changeTrackingKey = changeTrackingKey;
        this.pagerDiffer = differs.find([]).create();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    PagerInputBase.prototype.setPageSize = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        this.innerValue = value;
        // tslint:disable-next-line:prefer-switch
        if (value === null || value === undefined || value === '') {
            return;
        }
        this.value = value;
        setTimeout(function () { return (_this.innerValue = _this.value); }, 0);
    };
    /**
     * @return {?}
     */
    PagerInputBase.prototype.restoreInputValue = /**
     * @return {?}
     */
    function () {
        this.innerValue = this.value;
    };
    /**
     * @return {?}
     */
    PagerInputBase.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.restoreInputValue();
    };
    /**
     * @return {?}
     */
    PagerInputBase.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var pagerDiff = this.pagerDiffer.diff(this.pager);
        if (pagerDiff) {
            pagerDiff.forEachChangedItem(this.checkValueChanged);
        }
    };
    PagerInputBase.propDecorators = {
        innerValue: [{ type: HostBinding, args: ['value',] }],
        setPageSize: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
        restoreInputValue: [{ type: HostListener, args: ['blur',] }]
    };
    return PagerInputBase;
}());

var __extends$c = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PageNumberDirective = /** @class */ (function (_super) {
    __extends$c(PageNumberDirective, _super);
    function PageNumberDirective(pager, differs) {
        return _super.call(this, pager, differs, 'pageNumberInternal') || this;
    }
    Object.defineProperty(PageNumberDirective.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this.pager.pageNumber;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.pager.pageNumber = value;
        },
        enumerable: true,
        configurable: true
    });
    PageNumberDirective.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line:directive-selector */
                    selector: 'input[rtPageNumber]'
                },] },
    ];
    /** @nocollapse */
    PageNumberDirective.ctorParameters = function () { return [
        { type: PagedPager },
        { type: KeyValueDiffers }
    ]; };
    return PageNumberDirective;
}(PagerInputBase));

var __extends$d = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PageSizeDirective = /** @class */ (function (_super) {
    __extends$d(PageSizeDirective, _super);
    function PageSizeDirective(pager, differs) {
        return _super.call(this, pager, differs, 'pageSizeInternal') || this;
    }
    Object.defineProperty(PageSizeDirective.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this.pager.pageSize;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.pager.pageSize = value;
        },
        enumerable: true,
        configurable: true
    });
    PageSizeDirective.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line:directive-selector */
                    selector: 'input[rtPageSize]'
                },] },
    ];
    /** @nocollapse */
    PageSizeDirective.ctorParameters = function () { return [
        { type: PagedPager },
        { type: KeyValueDiffers }
    ]; };
    return PageSizeDirective;
}(PagerInputBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var PagedPagerComponent = /** @class */ (function () {
    function PagedPagerComponent(pager, listService) {
        this.pager = pager;
        this.listService = listService;
        this.defaultPageSize = PagedPager.settings.defaultPageSize;
        this.maxPageSize = PagedPager.settings.maxPageSize;
        this.minPageSize = PagedPager.settings.minPageSize;
        listService.pager = pager;
    }
    /**
     * @return {?}
     */
    PagedPagerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.pager.pageSize = this.defaultPageSize * 1;
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    PagedPagerComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.defaultPageSize) {
            this.pager.defaultPageSize = changes.defaultPageSize.currentValue * 1;
        }
        if (changes.maxPageSize) {
            this.pager.maxPageSize = changes.maxPageSize.currentValue * 1;
        }
        if (changes.minPageSize) {
            this.pager.minPageSize = changes.minPageSize.currentValue * 1;
        }
    };
    Object.defineProperty(PagedPagerComponent.prototype, "canMoveForward", {
        get: /**
         * @return {?}
         */
        function () {
            return this.pager.canMoveForward;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedPagerComponent.prototype, "canMoveBackward", {
        get: /**
         * @return {?}
         */
        function () {
            return this.pager.canMoveBackward;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    PagedPagerComponent.prototype.goToFirstPage = /**
     * @return {?}
     */
    function () {
        if (this.pager.tryMoveToFirstPage()) {
            return this.listService.loadData();
        }
        return null;
    };
    /**
     * @return {?}
     */
    PagedPagerComponent.prototype.goToLastPage = /**
     * @return {?}
     */
    function () {
        if (this.pager.tryMoveToLastPage()) {
            return this.listService.loadData();
        }
        return null;
    };
    /**
     * @return {?}
     */
    PagedPagerComponent.prototype.goToNextPage = /**
     * @return {?}
     */
    function () {
        if (this.pager.tryMoveToNextPage()) {
            return this.listService.loadData();
        }
        return null;
    };
    /**
     * @return {?}
     */
    PagedPagerComponent.prototype.goToPreviousPage = /**
     * @return {?}
     */
    function () {
        if (this.pager.tryMoveToPreviousPage()) {
            return this.listService.loadData();
        }
        return null;
    };
    /**
     * @return {?}
     */
    PagedPagerComponent.prototype.loadData = /**
     * @return {?}
     */
    function () {
        return this.listService.loadData();
    };
    PagedPagerComponent.decorators = [
        { type: Component, args: [{
                    providers: [{ provide: PagedPager, useClass: RTPagedPager }],
                    selector: 'rt-paged-pager',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    /** @nocollapse */
    PagedPagerComponent.ctorParameters = function () { return [
        { type: PagedPager },
        { type: RTList }
    ]; };
    PagedPagerComponent.propDecorators = {
        defaultPageSize: [{ type: Input }],
        maxPageSize: [{ type: Input }],
        minPageSize: [{ type: Input }]
    };
    return PagedPagerComponent;
}());

var __extends$e = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RowCountDirective = /** @class */ (function (_super) {
    __extends$e(RowCountDirective, _super);
    function RowCountDirective(bufferedPager, differs) {
        return _super.call(this, bufferedPager, differs, 'takeRowCountInternal') || this;
    }
    Object.defineProperty(RowCountDirective.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this.pager.takeRowCount;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.pager.takeRowCount = value;
        },
        enumerable: true,
        configurable: true
    });
    RowCountDirective.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line:directive-selector */
                    selector: 'input[rtRowCount]'
                },] },
    ];
    /** @nocollapse */
    RowCountDirective.ctorParameters = function () { return [
        { type: BufferedPager },
        { type: KeyValueDiffers }
    ]; };
    return RowCountDirective;
}(PagerInputBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var RTListsModule = /** @class */ (function () {
    function RTListsModule() {
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    RTListsModule.registerStateService = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
        LIST_PROVIDERS.push({
            deps: deps,
            multi: multi,
            provide: RTStateService,
            useClass: useClass,
            useExisting: useExisting,
            useFactory: useFactory,
            useValue: useValue
        });
    };
    RTListsModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ListDirective,
                        StatusNoDataComponent,
                        StatusRequestCancelledComponent,
                        StatusDoneComponent,
                        StatusFailedComponent,
                        StatusInitialComponent,
                        StatusInProgressComponent,
                        RowNumberPipe,
                        SortDirective,
                        PagedPagerComponent,
                        PageSizeDirective,
                        PageNumberDirective,
                        BufferedPagerComponent,
                        InfiniteDirective,
                        RowCountDirective
                    ],
                    exports: [
                        ListDirective,
                        StatusNoDataComponent,
                        StatusRequestCancelledComponent,
                        StatusDoneComponent,
                        StatusFailedComponent,
                        StatusInitialComponent,
                        StatusInProgressComponent,
                        RowNumberPipe,
                        SortDirective,
                        PagedPagerComponent,
                        PageSizeDirective,
                        PageNumberDirective,
                        BufferedPagerComponent,
                        InfiniteDirective,
                        RowCountDirective
                    ],
                    imports: [CommonModule]
                },] },
    ];
    return RTListsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var RTModule = /** @class */ (function () {
    function RTModule() {
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    RTModule.registerStateService = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
        RTListsModule.registerStateService({ useClass: useClass, useValue: useValue, useExisting: useExisting, useFactory: useFactory, deps: deps, multi: multi });
    };
    RTModule.decorators = [
        { type: NgModule, args: [{
                    exports: [RTListsModule, RTSelectionModule, RTMiscModule, RTFiltersModule],
                    imports: [RTListsModule, RTSelectionModule, RTMiscModule, RTFiltersModule]
                },] },
    ];
    return RTModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { RTModule, RTMiscModule, FocusOnRenderDirective, SelectOnFocusDirective, StopEventsDirective, PreventDefaultsDirective, RTFiltersModule, RegisterAsFilterDirective, RTFiltersService, RTSelectionModule, RTSelectionService, RTSelectionEventsHelper, SelectableDirective, SelectionAreaDirective, SelectionCheckboxForDirective, RTListsModule, RTList, RTBufferedPager, RTPagedPager, RTOperationStatus, RTSortingsService, RTFilterTarget, ListDirective, StatusNoDataComponent, StatusRequestCancelledComponent, StatusDoneComponent, StatusFailedComponent, StatusInitialComponent, StatusInProgressComponent, RowNumberPipe, SortDirective, PagedPagerComponent, PageSizeDirective, PageNumberDirective, BufferedPagerComponent, InfiniteDirective, RowCountDirective, LIST_PROVIDERS, RTStateService, PagerInputBase as b, StatusComponentBase as a, EventsAttacherBase as c };
