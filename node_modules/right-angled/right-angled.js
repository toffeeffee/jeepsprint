import { Directive, ElementRef, Input, Renderer2, HostListener, NgModule, Injectable, EventEmitter, Output, SkipSelf, HostBinding, ContentChildren, Self, Inject, InjectionToken, Optional, Component, KeyValueDiffers, Pipe, IterableDiffers } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FiltersService, DefaultSelectionService, SelectionEventsHelper, AsyncSubscriber, BufferedPager, List, PagedPager, SortingsService, StateService, OperationStatus, SortDirection } from 'e2e4';
export { cloneAsLiteral, coerceValue, destroyAll, coerceTypes, OperationStatus, SortDirection, PushBasedSubscriptionProxy, PromiseSubscriptionProxy, AsyncSubscriber, BufferedPager, getDefaultFilterConfig, filter, DefaultFilterConfig, FiltersService, List, PagedPager, KeyCodes, MouseButtons, SelectionEventsHelper, DefaultSelectionService, NullObjectPager, Operation, SortingsService, StateService, StatusTrackingService } from 'e2e4';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FocusOnRenderDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // we need set timeout for the cases when element itself is rendered by *ngIf directive and we need to wait it's rendering
        setTimeout(() => this.elementRef.nativeElement.focus(), 0);
    }
}
FocusOnRenderDirective.decorators = [
    { type: Directive, args: [{
                selector: '[rtFocusOnRender]'
            },] },
];
/** @nocollapse */
FocusOnRenderDirective.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class EventsAttacherBase {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} eventListener
     */
    constructor(elementRef, renderer, eventListener) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.eventListener = eventListener;
        this.eventListeners = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.eventNames) {
            this.removeListeners();
            this.addListeners(this.adjustEvents(changes.eventNames.currentValue));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListeners();
    }
    /**
     * @param {?} eventsNames
     * @return {?}
     */
    adjustEvents(eventsNames) {
        return eventsNames ? (Array.isArray(eventsNames) ? eventsNames : [eventsNames]) : [];
    }
    /**
     * @return {?}
     */
    removeListeners() {
        this.eventListeners.forEach(listener => {
            if (typeof listener === 'function') {
                listener();
            }
        });
        this.eventListeners = [];
    }
    /**
     * @param {?} eventNames
     * @return {?}
     */
    addListeners(eventNames) {
        if (!eventNames || !eventNames.length) {
            return;
        }
        this.eventListeners = eventNames.map(eventName => this.renderer.listen(this.elementRef.nativeElement, eventName, this.eventListener));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PreventDefaultsDirective extends EventsAttacherBase {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        super(elementRef, renderer, (evt) => {
            evt.preventDefault();
        });
    }
}
PreventDefaultsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[rtPreventDefaults]'
            },] },
];
/** @nocollapse */
PreventDefaultsDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
PreventDefaultsDirective.propDecorators = {
    eventNames: [{ type: Input, args: ['rtPreventDefaults',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SelectOnFocusDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.elementRef.nativeElement.select([]);
    }
}
SelectOnFocusDirective.decorators = [
    { type: Directive, args: [{
                selector: '[rtSelectOnFocus]'
            },] },
];
/** @nocollapse */
SelectOnFocusDirective.ctorParameters = () => [
    { type: ElementRef }
];
SelectOnFocusDirective.propDecorators = {
    onFocus: [{ type: HostListener, args: ['focus',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class StopEventsDirective extends EventsAttacherBase {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        super(elementRef, renderer, (evt) => {
            evt.stopPropagation();
        });
    }
}
StopEventsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[rtStopEvents]'
            },] },
];
/** @nocollapse */
StopEventsDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
StopEventsDirective.propDecorators = {
    eventNames: [{ type: Input, args: ['rtStopEvents',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RTMiscModule {
}
RTMiscModule.decorators = [
    { type: NgModule, args: [{
                declarations: [FocusOnRenderDirective, SelectOnFocusDirective, StopEventsDirective, PreventDefaultsDirective],
                exports: [FocusOnRenderDirective, SelectOnFocusDirective, StopEventsDirective, PreventDefaultsDirective],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RegisterAsFilterDirective {
    /**
     * @param {?} filtersService
     */
    constructor(filtersService) {
        this.filtersService = filtersService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.filtersService.registerFilterTarget(this.filterTarget);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.filtersService.removeFilterTarget(this.filterTarget);
    }
}
RegisterAsFilterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[rtRegisterAsFilter]'
            },] },
];
/** @nocollapse */
RegisterAsFilterDirective.ctorParameters = () => [
    { type: FiltersService }
];
RegisterAsFilterDirective.propDecorators = {
    filterTarget: [{ type: Input, args: ['rtRegisterAsFilter',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RTFiltersService extends FiltersService {
    constructor() {
        super();
    }
}
RTFiltersService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RTFiltersService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RTFiltersModule {
}
RTFiltersModule.decorators = [
    { type: NgModule, args: [{
                declarations: [RegisterAsFilterDirective],
                exports: [RegisterAsFilterDirective],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RTSelectionService extends DefaultSelectionService {
    constructor() {
        super(...arguments);
        this.eventEmitters = new Array();
        this.childSelectionServices = new Array();
    }
    /**
     * @return {?}
     */
    destroy() {
        this.areaEventsEmitter = null;
        this.eventEmitters.length = 0;
        super.destroy();
    }
    /**
     * @param {?=} recursive
     * @return {?}
     */
    selectAll(recursive = true) {
        super.selectAll();
        // run this directly after render to give child selectionAreas ability to render
        setTimeout(() => {
            if (recursive && this.childSelectionServices) {
                this.childSelectionServices.forEach(service => {
                    service.selectAll(recursive);
                });
            }
        }, 0);
    }
    /**
     * @param {?=} recursive
     * @return {?}
     */
    deselectAll(recursive = true) {
        if (recursive && this.childSelectionServices) {
            this.childSelectionServices.forEach(service => {
                service.deselectAll(recursive);
            });
        }
        super.deselectAll();
    }
    /**
     * @param {?} tuple
     * @param {?} selected
     * @return {?}
     */
    processSelection(tuple, selected) {
        /** @type {?} */
        const initialSelectState = this.eventEmitters[tuple.index]
            ? this.eventEmitters[tuple.index].selected || null
            : null;
        if (initialSelectState === null || initialSelectState !== selected) {
            if (this.eventEmitters.length > tuple.index && this.eventEmitters[tuple.index]) {
                this.emitEvents(this.eventEmitters[tuple.index], selected, tuple);
                this.eventEmitters[tuple.index].postProcessSelection(selected);
            }
            if (this.areaEventsEmitter) {
                this.emitEvents(this.areaEventsEmitter, selected, tuple);
            }
        }
    }
    /**
     * @param {?} emitter
     * @param {?} selected
     * @param {?} tuple
     * @return {?}
     */
    emitEvents(emitter, selected, tuple) {
        if (selected) {
            emitter.itemSelected.emit({ index: tuple.index, item: tuple.item });
        }
        else {
            emitter.itemDeselected.emit({ index: tuple.index, item: tuple.item });
        }
        emitter.selectionChanged.emit({ index: tuple.index, item: tuple.item });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RTSelectionEventsHelper extends SelectionEventsHelper {
    /**
     * @param {?} selectionService
     */
    constructor(selectionService) {
        super(selectionService);
        this.preventEventsDefaults = true;
        this.stopEventsPropagation = true;
        this.multiple = true;
    }
}
RTSelectionEventsHelper.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RTSelectionEventsHelper.ctorParameters = () => [
    { type: RTSelectionService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SelectableDirective {
    /**
     * @param {?} selectionEventsHelper
     * @param {?} renderer
     * @param {?} el
     */
    constructor(selectionEventsHelper, renderer, el) {
        this.selectionEventsHelper = selectionEventsHelper;
        this.renderer = renderer;
        this.el = el;
        this.index = null;
        /* tslint:disable-next-line:no-input-rename */
        this.item = null;
        this.selectedChange = new EventEmitter();
        this.itemSelected = new EventEmitter();
        this.itemDeselected = new EventEmitter();
        this.selectionChanged = new EventEmitter();
        this.selectedInternal = false;
    }
    /**
     * @return {?}
     */
    get selected() {
        return this.selectedInternal;
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    set selected(selected) {
        if (selected) {
            this.selectionEventsHelper.selectionService.selectIndex(this.index, this.selectionEventsHelper.multiple);
        }
        else {
            this.selectionEventsHelper.selectionService.deselectIndex(this.index);
        }
    }
    /**
     * @param {?} ctrlKeyPressed
     * @param {?} shiftKeyPressed
     * @param {?} mouseButton
     * @param {?} preventDefaultFn
     * @param {?} stopPropagationFn
     * @param {?} executionContext
     * @return {?}
     */
    mouseUpHandler(ctrlKeyPressed, shiftKeyPressed, mouseButton, preventDefaultFn, stopPropagationFn, executionContext) {
        if (this.selectionEventsHelper.mouseHandler(ctrlKeyPressed, shiftKeyPressed, mouseButton, this.index)) {
            this.clearWindowSelection();
            if (this.selectionEventsHelper.preventEventsDefaults && preventDefaultFn) {
                preventDefaultFn.call(executionContext);
            }
            if (this.selectionEventsHelper.stopEventsPropagation && stopPropagationFn) {
                stopPropagationFn.call(executionContext);
            }
        }
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    postProcessSelection(selected) {
        if (selected === this.selected) {
            return;
        }
        this.selectedInternal = selected;
        this.selectedChange.emit(this.selectedInternal);
        if (SelectableDirective.settings.selectedClassName) {
            if (this.selected) {
                this.renderer.addClass(this.el.nativeElement, SelectableDirective.settings.selectedClassName);
            }
            else {
                this.renderer.removeClass(this.el.nativeElement, SelectableDirective.settings.selectedClassName);
            }
        }
    }
    /**
     * @return {?}
     */
    clearWindowSelection() {
        try {
            window.getSelection().removeAllRanges();
        }
        catch (e) {
            // do nothing
        }
    }
}
SelectableDirective.settings = {
    selectedClassName: 'rt-selected'
};
SelectableDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'rtSelectable',
                selector: '[rtSelectable]'
            },] },
];
/** @nocollapse */
SelectableDirective.ctorParameters = () => [
    { type: RTSelectionEventsHelper, decorators: [{ type: SkipSelf }] },
    { type: Renderer2 },
    { type: ElementRef }
];
SelectableDirective.propDecorators = {
    item: [{ type: Input, args: ['rtSelectable',] }],
    selectedChange: [{ type: Output }],
    itemSelected: [{ type: Output }],
    itemDeselected: [{ type: Output }],
    selectionChanged: [{ type: Output }],
    selected: [{ type: Input }],
    mouseUpHandler: [{ type: HostListener, args: ['mouseup', [
                    '$event.ctrlKey',
                    '$event.shiftKey',
                    '$event.which',
                    '$event.preventDefault',
                    '$event.stopPropagation',
                    '$event'
                ],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SelectionCheckboxForDirective {
    /**
     * @param {?} selectionEventsHelper
     * @param {?} selectionService
     */
    constructor(selectionEventsHelper, selectionService) {
        this.selectionEventsHelper = selectionEventsHelper;
        this.selectionService = selectionService;
        this.index = null;
        /* tslint:disable-next-line:no-input-rename */
        this.item = null;
        this.selectedChange = new EventEmitter();
        this.itemSelected = new EventEmitter();
        this.itemDeselected = new EventEmitter();
        this.selectionChanged = new EventEmitter();
        this.selectedInternal = false;
    }
    /**
     * @return {?}
     */
    get selected() {
        return this.selectedInternal;
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    set selected(selected) {
        if (selected) {
            this.selectionService.selectIndex(this.index, this.selectionEventsHelper.multiple);
        }
        else {
            this.selectionService.deselectIndex(this.index);
        }
    }
    /**
     * @return {?}
     */
    get isChecked() {
        return this.selectionService.isIndexSelected(this.index);
    }
    /**
     * @param {?} isChecked
     * @return {?}
     */
    changeHandler(isChecked) {
        if (isChecked) {
            this.selectionService.selectIndex(this.index, this.selectionEventsHelper.multiple);
        }
        else {
            this.selectionService.deselectIndex(this.index);
        }
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    postProcessSelection(selected) {
        if (selected === this.selected) {
            return;
        }
        this.selectedInternal = selected;
        this.selectedChange.emit(this.selectedInternal);
    }
}
SelectionCheckboxForDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'rtSelectionCheckboxFor',
                /* tslint:disable-next-line:directive-selector */
                selector: 'input[rtSelectionCheckboxFor]'
            },] },
];
/** @nocollapse */
SelectionCheckboxForDirective.ctorParameters = () => [
    { type: RTSelectionEventsHelper, decorators: [{ type: SkipSelf }] },
    { type: RTSelectionService, decorators: [{ type: SkipSelf }] }
];
SelectionCheckboxForDirective.propDecorators = {
    item: [{ type: Input, args: ['rtSelectionCheckboxFor',] }],
    selected: [{ type: Input }],
    selectedChange: [{ type: Output }],
    itemSelected: [{ type: Output }],
    itemDeselected: [{ type: Output }],
    selectionChanged: [{ type: Output }],
    isChecked: [{ type: HostBinding, args: ['checked',] }],
    changeHandler: [{ type: HostListener, args: ['change', ['$event.target.checked'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SelectionAreaDirective {
    /**
     * @param {?} selectionService
     * @param {?} selectionEventsHelper
     */
    constructor(selectionService, selectionEventsHelper) {
        this.selectionService = selectionService;
        this.selectionEventsHelper = selectionEventsHelper;
        this.tabIndex = 0;
        this.autoSelectFirst = false;
        this.itemSelected = new EventEmitter();
        this.itemDeselected = new EventEmitter();
        this.selectionChanged = new EventEmitter();
        this.selectionService.areaEventsEmitter = this;
        this.selectionEventsHelper = selectionEventsHelper;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set preventEventsDefaults(value) {
        this.selectionEventsHelper.preventEventsDefaults = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set stopEventsPropagation(value) {
        this.selectionEventsHelper.stopEventsPropagation = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set horizontal(value) {
        this.selectionEventsHelper.horizontal = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set multiple(value) {
        this.selectionEventsHelper.multiple = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set toggleOnly(value) {
        this.selectionEventsHelper.toggleOnly = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set trackBy(value) {
        if (typeof value !== 'function') {
            throw new Error('trackBy parameter value must be a function');
        }
        this.selectionService.trackByFn = value;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.itemsSubscription.unsubscribe();
        this.checkboxesSubscription.unsubscribe();
        this.childSelectionAreasSubscription.unsubscribe();
        this.selectionService.deselectAll();
        this.selectionService.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (false === this.selectionService.hasSelections() &&
            changes.autoSelectFirst &&
            changes.autoSelectFirst.currentValue === true) {
            this.selectionService.selectIndex(0, false);
        }
        if (changes.multiple && changes.multiple.currentValue === false) {
            /** @type {?} */
            const selectedIndexes = this.selectionService.getSelectedIndexes();
            if (selectedIndexes.length > 1) {
                selectedIndexes.splice(0, 1);
                selectedIndexes.forEach(index => {
                    this.selectionService.deselectIndex(index);
                });
            }
        }
    }
    /**
     * @param {?} ctrlKeyPressed
     * @param {?} shiftKeyPressed
     * @param {?} keyCode
     * @param {?} preventDefaultFn
     * @param {?} stopPropagationFn
     * @param {?} executionContext
     * @return {?}
     */
    keyDownHandler(ctrlKeyPressed, shiftKeyPressed, keyCode, preventDefaultFn, stopPropagationFn, executionContext) {
        if (this.selectionEventsHelper.keyboardHandler(ctrlKeyPressed, shiftKeyPressed, keyCode)) {
            if (this.selectionEventsHelper.preventEventsDefaults && preventDefaultFn) {
                preventDefaultFn.call(executionContext);
            }
            if (this.selectionEventsHelper.stopEventsPropagation && stopPropagationFn) {
                stopPropagationFn.call(executionContext);
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.selectableItems.length > 0) {
            this.buildSelectionSource(this.selectableItems);
        }
        if (this.childSelectionCheckboxes.length > 0) {
            this.buildSelectionSource(this.childSelectionCheckboxes);
        }
        this.buildSelectionServicesList(this.childSelectionAreas);
        this.itemsSubscription = this.selectableItems.changes.subscribe(this.buildSelectionSource.bind(this));
        this.checkboxesSubscription = this.childSelectionCheckboxes.changes.subscribe(this.buildSelectionSource.bind(this));
        this.childSelectionAreasSubscription = this.childSelectionAreas.changes.subscribe(this.buildSelectionServicesList.bind(this));
    }
    /**
     * @param {?} items
     * @return {?}
     */
    buildSelectionSource(items) {
        /** @type {?} */
        let index = 0;
        this.selectionService.eventEmitters = items.map(item => {
            item.index = index++;
            return item;
        });
        this.selectionService.items = items.map(item => item.item);
        if (this.selectionService.items.length > 0) {
            setTimeout(() => {
                // since we've modify collection on first render, to prevent error 'Expression has changed after it was checked' we've do selection after render
                if (this.selectionService.items.length > 0) {
                    this.selectionService.checkSelection();
                    // repeats first element selection since checking can deselect all elements
                    if (false === this.selectionService.hasSelections() && this.autoSelectFirst) {
                        this.selectionService.selectIndex(0, false);
                    }
                }
            }, 0);
        }
    }
    /**
     * @param {?} items
     * @return {?}
     */
    buildSelectionServicesList(items) {
        this.selectionService.childSelectionServices = items
            .filter(area => area !== this)
            .map(area => area.selectionService);
    }
}
SelectionAreaDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'rtSelectionArea',
                providers: [RTSelectionService, RTSelectionEventsHelper],
                selector: '[rtSelectionArea]'
            },] },
];
/** @nocollapse */
SelectionAreaDirective.ctorParameters = () => [
    { type: RTSelectionService, decorators: [{ type: Self }] },
    { type: RTSelectionEventsHelper, decorators: [{ type: Self }] }
];
SelectionAreaDirective.propDecorators = {
    selectableItems: [{ type: ContentChildren, args: [SelectableDirective, { descendants: false },] }],
    childSelectionCheckboxes: [{ type: ContentChildren, args: [SelectionCheckboxForDirective, { descendants: false },] }],
    childSelectionAreas: [{ type: ContentChildren, args: [SelectionAreaDirective, { descendants: false },] }],
    tabIndex: [{ type: HostBinding, args: ['tabIndex',] }],
    preventEventsDefaults: [{ type: Input }],
    stopEventsPropagation: [{ type: Input }],
    horizontal: [{ type: Input }],
    multiple: [{ type: Input }],
    toggleOnly: [{ type: Input }],
    autoSelectFirst: [{ type: Input }],
    trackBy: [{ type: Input }],
    itemSelected: [{ type: Output }],
    itemDeselected: [{ type: Output }],
    selectionChanged: [{ type: Output }],
    keyDownHandler: [{ type: HostListener, args: ['keydown', [
                    '$event.ctrlKey',
                    '$event.shiftKey',
                    '$event.keyCode',
                    '$event.preventDefault',
                    '$event.stopPropagation',
                    '$event'
                ],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RTSelectionModule {
}
RTSelectionModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SelectableDirective, SelectionAreaDirective, SelectionCheckboxForDirective],
                exports: [SelectableDirective, SelectionAreaDirective, SelectionCheckboxForDirective],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const RTFilterTarget = new InjectionToken('RTFilterTarget');
/**
 * @abstract
 */
class RTStateService extends StateService {
}
class RTOperationStatus {
}
class RTList extends List {
    /**
     * @param {?} asyncSubscriber
     * @param {?} stateServices
     * @param {?} filterTargets
     * @param {?} sortingsService
     * @param {?} filtersService
     */
    constructor(asyncSubscriber, stateServices, filterTargets, sortingsService, filtersService) {
        super(asyncSubscriber, stateServices, sortingsService, filtersService);
        this.loadStarted = new EventEmitter();
        this.loadSucceed = new EventEmitter();
        this.loadFailed = new EventEmitter();
        this.filterTargets = [];
        if (filterTargets != null) {
            if (Array.isArray(filterTargets)) {
                this.filterTargets.push(...filterTargets);
            }
            else {
                this.filterTargets.push(filterTargets);
            }
        }
    }
    /**
     * @param {?} response
     * @return {?}
     */
    loadSuccessCallback(response) {
        /** @type {?} */
        const result = super.loadSuccessCallback(response);
        this.loadSucceed.emit(result);
        return result;
    }
    /**
     * @return {?}
     */
    loadFailCallback() {
        super.loadFailCallback();
        this.loadFailed.emit();
    }
    /**
     * @return {?}
     */
    loadData() {
        /** @type {?} */
        const subscribable = super.loadData();
        this.loadStarted.emit();
        return subscribable;
    }
    /**
     * @return {?}
     */
    reloadData() {
        /** @type {?} */
        const subscribable = super.reloadData();
        this.loadStarted.emit();
        return subscribable;
    }
    /**
     * @return {?}
     */
    init() {
        this.filtersService.registerFilterTarget(...this.filterTargets);
        super.init();
    }
}
RTList.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RTList.ctorParameters = () => [
    { type: AsyncSubscriber },
    { type: RTStateService, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [RTFilterTarget,] }] },
    { type: SortingsService },
    { type: FiltersService }
];
class RTPagedPager extends PagedPager {
}
RTPagedPager.decorators = [
    { type: Injectable },
];
class RTBufferedPager extends BufferedPager {
}
RTBufferedPager.decorators = [
    { type: Injectable },
];
class RTSortingsService extends SortingsService {
}
RTSortingsService.decorators = [
    { type: Injectable },
];
/** @type {?} */
let LIST_PROVIDERS = [
    AsyncSubscriber,
    RTList,
    { provide: FiltersService, useClass: RTFiltersService },
    { provide: RTOperationStatus, useExisting: RTList },
    { provide: SortingsService, useClass: RTSortingsService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ListDirective {
    /**
     * @param {?} listService
     * @param {?} sortingsService
     */
    constructor(listService, sortingsService) {
        this.listService = listService;
        this.sortingsService = sortingsService;
        this.listInit = new EventEmitter(false);
        this.afterListInit = new EventEmitter(false);
        this.loadSucceed = new EventEmitter();
        this.loadFailed = new EventEmitter();
        this.loadStarted = new EventEmitter();
        this.loadOnInit = true;
        this.keepRecordsOnLoad = false;
        this.successSubscription = listService.loadSucceed.subscribe((response) => {
            this.loadSucceed.emit(response);
        });
        this.failSubscription = listService.loadFailed.subscribe(() => {
            this.loadFailed.emit();
        });
        this.loadStartedSubscription = listService.loadStarted.subscribe(() => {
            this.loadStarted.emit();
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set fetchMethod(value) {
        this.listService.fetchMethod = value;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // We call init in ngAfterViewInit to:
        // 1. allow all child controls to be applied to markup and regiter themself in filtersService
        // 2. give ability to all child controls to apply their default values
        // 3. overwrite theese default values by values passed via persistence services
        // 4. execute all ngAfterViewInit for custom services registration (setTimeout)
        setTimeout(() => {
            this.listInit.emit(this.listService);
            this.listService.init();
            this.afterListInit.emit(this.listService);
            if (this.loadOnInit) {
                this.listService.loadData();
            }
        }, 0);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.listService.destroy();
        this.successSubscription.unsubscribe();
        this.failSubscription.unsubscribe();
        this.loadStartedSubscription.unsubscribe();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.defaultSortings) {
            this.sortingsService.defaultSortings = changes.defaultSortings.currentValue;
        }
        if (changes.keepRecordsOnLoad) {
            this.listService.keepRecordsOnLoad = changes.keepRecordsOnLoad.currentValue;
        }
    }
    /**
     * @return {?}
     */
    reloadData() {
        return this.listService.reloadData();
    }
    /**
     * @return {?}
     */
    loadData() {
        return this.listService.loadData();
    }
    /**
     * @return {?}
     */
    resetSettings() {
        this.listService.resetSettings();
    }
    /**
     * @return {?}
     */
    cancelRequests() {
        this.listService.cancelRequests();
    }
    /**
     * @return {?}
     */
    get items() {
        return this.listService.items;
    }
    /**
     * @return {?}
     */
    get busy() {
        return this.listService.busy;
    }
    /**
     * @return {?}
     */
    get ready() {
        return this.listService.ready;
    }
}
ListDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'rtList',
                providers: [LIST_PROVIDERS],
                selector: '[rtList]'
            },] },
];
/** @nocollapse */
ListDirective.ctorParameters = () => [
    { type: RTList, decorators: [{ type: Self }] },
    { type: SortingsService, decorators: [{ type: Self }] }
];
ListDirective.propDecorators = {
    listInit: [{ type: Output }],
    afterListInit: [{ type: Output }],
    loadSucceed: [{ type: Output }],
    loadFailed: [{ type: Output }],
    loadStarted: [{ type: Output }],
    defaultSortings: [{ type: Input }],
    loadOnInit: [{ type: Input }],
    keepRecordsOnLoad: [{ type: Input }],
    fetchMethod: [{ type: Input, args: ['rtList',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class StatusComponentBase {
    /**
     * @param {?} trackedStatusObject
     * @param {?} differs
     * @param {?} visibleState
     */
    constructor(trackedStatusObject, differs, visibleState) {
        this.trackedStatusObject = trackedStatusObject;
        this.checkStateFieldChanges = (item) => {
            if (item.key === 'status' || item.key === 'statusInternal') {
                this.setVisibility();
            }
        };
        this.visibleState = visibleState;
        this.listDiffer = differs.find([]).create();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setVisibility();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const stateDiff = this.listDiffer.diff(this.trackedStatusObject);
        if (stateDiff) {
            stateDiff.forEachChangedItem(this.checkStateFieldChanges);
        }
    }
    /**
     * @return {?}
     */
    setVisibility() {
        this.isVisible = this.trackedStatusObject.status === this.visibleState;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class StatusDoneComponent extends StatusComponentBase {
    /**
     * @param {?} trackedStatusObject
     * @param {?} differs
     */
    constructor(trackedStatusObject, differs) {
        super(trackedStatusObject, differs, OperationStatus.Done);
    }
}
StatusDoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'rt-status-done',
                template: `<ng-content *ngIf="isVisible"></ng-content>`
            },] },
];
/** @nocollapse */
StatusDoneComponent.ctorParameters = () => [
    { type: RTOperationStatus },
    { type: KeyValueDiffers }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class StatusFailedComponent extends StatusComponentBase {
    /**
     * @param {?} trackedStatusObject
     * @param {?} differs
     */
    constructor(trackedStatusObject, differs) {
        super(trackedStatusObject, differs, OperationStatus.Fail);
    }
}
StatusFailedComponent.decorators = [
    { type: Component, args: [{
                selector: 'rt-status-failed',
                template: `<ng-content *ngIf="isVisible"></ng-content>`
            },] },
];
/** @nocollapse */
StatusFailedComponent.ctorParameters = () => [
    { type: RTOperationStatus },
    { type: KeyValueDiffers }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class StatusInProgressComponent extends StatusComponentBase {
    /**
     * @param {?} trackedStatusObject
     * @param {?} differs
     */
    constructor(trackedStatusObject, differs) {
        super(trackedStatusObject, differs, OperationStatus.Progress);
    }
}
StatusInProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'rt-status-progress',
                template: `<ng-content *ngIf="isVisible"></ng-content>`
            },] },
];
/** @nocollapse */
StatusInProgressComponent.ctorParameters = () => [
    { type: RTOperationStatus },
    { type: KeyValueDiffers }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class StatusInitialComponent extends StatusComponentBase {
    /**
     * @param {?} trackedStatusObject
     * @param {?} differs
     */
    constructor(trackedStatusObject, differs) {
        super(trackedStatusObject, differs, OperationStatus.Initial);
    }
}
StatusInitialComponent.decorators = [
    { type: Component, args: [{
                selector: 'rt-status-initial',
                template: `<ng-content *ngIf="isVisible"></ng-content>`
            },] },
];
/** @nocollapse */
StatusInitialComponent.ctorParameters = () => [
    { type: RTOperationStatus },
    { type: KeyValueDiffers }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class StatusNoDataComponent extends StatusComponentBase {
    /**
     * @param {?} trackedStatusObject
     * @param {?} differs
     */
    constructor(trackedStatusObject, differs) {
        super(trackedStatusObject, differs, OperationStatus.NoData);
    }
}
StatusNoDataComponent.decorators = [
    { type: Component, args: [{
                selector: 'rt-status-no-data',
                template: `<ng-content *ngIf="isVisible"></ng-content>`
            },] },
];
/** @nocollapse */
StatusNoDataComponent.ctorParameters = () => [
    { type: RTOperationStatus },
    { type: KeyValueDiffers }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class StatusRequestCancelledComponent extends StatusComponentBase {
    /**
     * @param {?} trackedStatusObject
     * @param {?} differs
     */
    constructor(trackedStatusObject, differs) {
        super(trackedStatusObject, differs, OperationStatus.Cancelled);
    }
}
StatusRequestCancelledComponent.decorators = [
    { type: Component, args: [{
                selector: 'rt-status-request-cancelled',
                template: `<ng-content *ngIf="isVisible"></ng-content>`
            },] },
];
/** @nocollapse */
StatusRequestCancelledComponent.ctorParameters = () => [
    { type: RTOperationStatus },
    { type: KeyValueDiffers }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RowNumberPipe {
    /**
     * @param {?} index
     * @param {?} rtList
     * @return {?}
     */
    transform(index, rtList) {
        if (index !== 0 && (!index || isNaN(index))) {
            throw new Error('Invalid input value for rtRowNumber pipe. Must be a valid numeric value.');
        }
        if (!rtList) {
            throw new Error('Invalid value provided for parameter "rtList" of rtRowNumber pipe . Must be "rtList" directive instance.');
        }
        if (rtList.listService.pager !== null && (/** @type {?} */ (rtList.listService.pager)).displayFrom) {
            return index + (/** @type {?} */ (rtList.listService.pager)).displayFrom;
        }
        else {
            return index + 1;
        }
    }
}
RowNumberPipe.decorators = [
    { type: Pipe, args: [{ name: 'rtRowNumber' },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SortDirective {
    /**
     * @param {?} listService
     * @param {?} sortingsService
     * @param {?} renderer
     * @param {?} el
     * @param {?} differs
     */
    constructor(listService, sortingsService, renderer, el, differs) {
        this.listService = listService;
        this.sortingsService = sortingsService;
        this.renderer = renderer;
        this.sortItemRemovedCallback = (removedItem) => {
            if (removedItem.item && removedItem.item.fieldName === this.fieldName) {
                this.removeSortClasses();
            }
        };
        this.sortItemAddedCallback = (addedItem) => {
            if (addedItem.item && addedItem.item.fieldName === this.fieldName) {
                this.setSortClasses(addedItem.item);
            }
        };
        this.sortingsDiffer = differs.find([]).create(null);
        this.nativeEl = el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (SortDirective.settings.sortableClassName) {
            this.renderer.addClass(this.nativeEl, SortDirective.settings.sortableClassName);
        }
        this.sortingsService.sortings.some(sortParameter => {
            if (sortParameter.fieldName === this.fieldName) {
                this.setSortClasses(sortParameter);
                return true;
            }
            return false;
        });
    }
    /**
     * @param {?} ctrlKeyPressed
     * @return {?}
     */
    clickHandler(ctrlKeyPressed) {
        if (this.listService.ready && !this.disableSort) {
            this.sortingsService.setSort(this.fieldName, ctrlKeyPressed);
            this.listService.reloadData();
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const changes = this.sortingsDiffer.diff(this.sortingsService.sortings);
        if (changes) {
            changes.forEachRemovedItem(this.sortItemRemovedCallback);
            changes.forEachAddedItem(this.sortItemAddedCallback);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.disableSort && changes.disableSort.currentValue) {
            this.sortingsService.removeSort(this.fieldName);
        }
    }
    /**
     * @return {?}
     */
    removeSortClasses() {
        if (SortDirective.settings.sortAscClassName) {
            this.renderer.removeClass(this.nativeEl, SortDirective.settings.sortAscClassName);
        }
        if (SortDirective.settings.sortDescClassName) {
            this.renderer.removeClass(this.nativeEl, SortDirective.settings.sortDescClassName);
        }
    }
    /**
     * @param {?} sortParameter
     * @return {?}
     */
    setSortClasses(sortParameter) {
        /** @type {?} */
        const direction = sortParameter.direction;
        if (SortDirective.settings.sortAscClassName) {
            if (direction === SortDirection.Asc) {
                this.renderer.addClass(this.nativeEl, SortDirective.settings.sortAscClassName);
            }
            else {
                this.renderer.removeClass(this.nativeEl, SortDirective.settings.sortAscClassName);
            }
        }
        if (SortDirective.settings.sortDescClassName) {
            if (direction === SortDirection.Desc) {
                this.renderer.addClass(this.nativeEl, SortDirective.settings.sortDescClassName);
            }
            else {
                this.renderer.removeClass(this.nativeEl, SortDirective.settings.sortDescClassName);
            }
        }
    }
}
SortDirective.settings = {
    sortAscClassName: 'rt-sort-asc',
    sortDescClassName: 'rt-sort-desc',
    sortableClassName: 'rt-sortable'
};
SortDirective.decorators = [
    { type: Directive, args: [{
                selector: '[rtSort]'
            },] },
];
/** @nocollapse */
SortDirective.ctorParameters = () => [
    { type: RTList, decorators: [{ type: SkipSelf }] },
    { type: SortingsService, decorators: [{ type: SkipSelf }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: IterableDiffers }
];
SortDirective.propDecorators = {
    fieldName: [{ type: Input, args: ['rtSort',] }],
    disableSort: [{ type: Input }],
    clickHandler: [{ type: HostListener, args: ['click', ['$event.ctrlKey'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class BufferedPagerComponent {
    /**
     * @param {?} pager
     * @param {?} listService
     */
    constructor(pager, listService) {
        this.pager = pager;
        this.listService = listService;
        this.defaultRowCount = RTBufferedPager.settings.defaultRowCount;
        this.maxRowCount = RTBufferedPager.settings.maxRowCount;
        this.minRowCount = RTBufferedPager.settings.minRowCount;
        this.listService.pager = pager;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.pager.takeRowCount = this.defaultRowCount * 1;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.defaultRowCount) {
            this.pager.defaultRowCount = changes.defaultRowCount.currentValue * 1;
        }
        if (changes.maxRowCount) {
            this.pager.maxRowCount = changes.maxRowCount.currentValue * 1;
        }
        if (changes.minRowCount) {
            this.pager.minRowCount = changes.minRowCount.currentValue * 1;
        }
    }
    /**
     * @return {?}
     */
    get canLoadMore() {
        return this.pager.canLoadMore;
    }
    /**
     * @return {?}
     */
    loadMore() {
        if (this.canLoadMore) {
            return this.listService.loadData();
        }
        return null;
    }
}
BufferedPagerComponent.decorators = [
    { type: Component, args: [{
                providers: [{ provide: BufferedPager, useClass: RTBufferedPager }],
                selector: 'rt-buffered-pager',
                template: '<ng-content></ng-content>'
            },] },
];
/** @nocollapse */
BufferedPagerComponent.ctorParameters = () => [
    { type: BufferedPager },
    { type: RTList }
];
BufferedPagerComponent.propDecorators = {
    defaultRowCount: [{ type: Input }],
    maxRowCount: [{ type: Input }],
    minRowCount: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class InfiniteDirective {
    /**
     * @param {?} elementRef
     * @param {?} bufferedPager
     * @param {?} list
     * @param {?} renderer
     */
    constructor(elementRef, bufferedPager, list, renderer) {
        this.elementRef = elementRef;
        this.bufferedPager = bufferedPager;
        this.list = list;
        this.renderer = renderer;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.scrollListener) {
            this.scrollListener();
        }
        if (changes.targetElement && changes.targetElement.currentValue) {
            this.scrollListener = this.renderer.listen(this.targetElement, 'scroll', () => {
                if (this.list.busy || false === this.bufferedPager.canLoadMore) {
                    return;
                }
                /** @type {?} */
                const targetTop = this.targetElement.getBoundingClientRect().top;
                /** @type {?} */
                const targetHeight = this.targetElement.clientHeight;
                /** @type {?} */
                const elementPosition = (/** @type {?} */ (this.elementRef.nativeElement)).getBoundingClientRect().top;
                if (targetTop + targetHeight >= elementPosition) {
                    this.list.loadData();
                }
            });
        }
        else {
            this.scrollListener = this.renderer.listen('window', 'scroll', () => {
                if (this.list.busy || false === this.bufferedPager.canLoadMore) {
                    return;
                }
                /** @type {?} */
                const windowHeight = document.documentElement.clientHeight;
                /** @type {?} */
                const elementPosition = (/** @type {?} */ (this.elementRef.nativeElement)).getBoundingClientRect().top;
                if (elementPosition - windowHeight <= 0) {
                    this.list.loadData();
                }
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.scrollListener();
    }
}
InfiniteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[rtInfinite]'
            },] },
];
/** @nocollapse */
InfiniteDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: BufferedPager },
    { type: RTList },
    { type: Renderer2 }
];
InfiniteDirective.propDecorators = {
    targetElement: [{ type: Input, args: ['rtInfinite',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class PagerInputBase {
    /**
     * @param {?} pager
     * @param {?} differs
     * @param {?} changeTrackingKey
     */
    constructor(pager, differs, changeTrackingKey) {
        this.pager = pager;
        this.checkValueChanged = (item) => {
            if (item.key === this.changeTrackingKey && item.currentValue !== this.innerValue) {
                this.innerValue = item.currentValue;
            }
        };
        this.changeTrackingKey = changeTrackingKey;
        this.pagerDiffer = differs.find([]).create();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setPageSize(value) {
        this.innerValue = value;
        // tslint:disable-next-line:prefer-switch
        if (value === null || value === undefined || value === '') {
            return;
        }
        this.value = value;
        setTimeout(() => (this.innerValue = this.value), 0);
    }
    /**
     * @return {?}
     */
    restoreInputValue() {
        this.innerValue = this.value;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.restoreInputValue();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const pagerDiff = this.pagerDiffer.diff(this.pager);
        if (pagerDiff) {
            pagerDiff.forEachChangedItem(this.checkValueChanged);
        }
    }
}
PagerInputBase.propDecorators = {
    innerValue: [{ type: HostBinding, args: ['value',] }],
    setPageSize: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
    restoreInputValue: [{ type: HostListener, args: ['blur',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PageNumberDirective extends PagerInputBase {
    /**
     * @param {?} pager
     * @param {?} differs
     */
    constructor(pager, differs) {
        super(pager, differs, 'pageNumberInternal');
    }
    /**
     * @return {?}
     */
    get value() {
        return this.pager.pageNumber;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.pager.pageNumber = value;
    }
}
PageNumberDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'input[rtPageNumber]'
            },] },
];
/** @nocollapse */
PageNumberDirective.ctorParameters = () => [
    { type: PagedPager },
    { type: KeyValueDiffers }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PageSizeDirective extends PagerInputBase {
    /**
     * @param {?} pager
     * @param {?} differs
     */
    constructor(pager, differs) {
        super(pager, differs, 'pageSizeInternal');
    }
    /**
     * @return {?}
     */
    get value() {
        return this.pager.pageSize;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.pager.pageSize = value;
    }
}
PageSizeDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'input[rtPageSize]'
            },] },
];
/** @nocollapse */
PageSizeDirective.ctorParameters = () => [
    { type: PagedPager },
    { type: KeyValueDiffers }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PagedPagerComponent {
    /**
     * @param {?} pager
     * @param {?} listService
     */
    constructor(pager, listService) {
        this.pager = pager;
        this.listService = listService;
        this.defaultPageSize = PagedPager.settings.defaultPageSize;
        this.maxPageSize = PagedPager.settings.maxPageSize;
        this.minPageSize = PagedPager.settings.minPageSize;
        listService.pager = pager;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.pager.pageSize = this.defaultPageSize * 1;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.defaultPageSize) {
            this.pager.defaultPageSize = changes.defaultPageSize.currentValue * 1;
        }
        if (changes.maxPageSize) {
            this.pager.maxPageSize = changes.maxPageSize.currentValue * 1;
        }
        if (changes.minPageSize) {
            this.pager.minPageSize = changes.minPageSize.currentValue * 1;
        }
    }
    /**
     * @return {?}
     */
    get canMoveForward() {
        return this.pager.canMoveForward;
    }
    /**
     * @return {?}
     */
    get canMoveBackward() {
        return this.pager.canMoveBackward;
    }
    /**
     * @return {?}
     */
    goToFirstPage() {
        if (this.pager.tryMoveToFirstPage()) {
            return this.listService.loadData();
        }
        return null;
    }
    /**
     * @return {?}
     */
    goToLastPage() {
        if (this.pager.tryMoveToLastPage()) {
            return this.listService.loadData();
        }
        return null;
    }
    /**
     * @return {?}
     */
    goToNextPage() {
        if (this.pager.tryMoveToNextPage()) {
            return this.listService.loadData();
        }
        return null;
    }
    /**
     * @return {?}
     */
    goToPreviousPage() {
        if (this.pager.tryMoveToPreviousPage()) {
            return this.listService.loadData();
        }
        return null;
    }
    /**
     * @return {?}
     */
    loadData() {
        return this.listService.loadData();
    }
}
PagedPagerComponent.decorators = [
    { type: Component, args: [{
                providers: [{ provide: PagedPager, useClass: RTPagedPager }],
                selector: 'rt-paged-pager',
                template: '<ng-content></ng-content>'
            },] },
];
/** @nocollapse */
PagedPagerComponent.ctorParameters = () => [
    { type: PagedPager },
    { type: RTList }
];
PagedPagerComponent.propDecorators = {
    defaultPageSize: [{ type: Input }],
    maxPageSize: [{ type: Input }],
    minPageSize: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RowCountDirective extends PagerInputBase {
    /**
     * @param {?} bufferedPager
     * @param {?} differs
     */
    constructor(bufferedPager, differs) {
        super(bufferedPager, differs, 'takeRowCountInternal');
    }
    /**
     * @return {?}
     */
    get value() {
        return this.pager.takeRowCount;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.pager.takeRowCount = value;
    }
}
RowCountDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'input[rtRowCount]'
            },] },
];
/** @nocollapse */
RowCountDirective.ctorParameters = () => [
    { type: BufferedPager },
    { type: KeyValueDiffers }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RTListsModule {
    /**
     * @param {?} __0
     * @return {?}
     */
    static registerStateService({ useClass, useValue, useExisting, useFactory, deps, multi }) {
        LIST_PROVIDERS.push({
            deps,
            multi,
            provide: RTStateService,
            useClass,
            useExisting,
            useFactory,
            useValue
        });
    }
}
RTListsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ListDirective,
                    StatusNoDataComponent,
                    StatusRequestCancelledComponent,
                    StatusDoneComponent,
                    StatusFailedComponent,
                    StatusInitialComponent,
                    StatusInProgressComponent,
                    RowNumberPipe,
                    SortDirective,
                    PagedPagerComponent,
                    PageSizeDirective,
                    PageNumberDirective,
                    BufferedPagerComponent,
                    InfiniteDirective,
                    RowCountDirective
                ],
                exports: [
                    ListDirective,
                    StatusNoDataComponent,
                    StatusRequestCancelledComponent,
                    StatusDoneComponent,
                    StatusFailedComponent,
                    StatusInitialComponent,
                    StatusInProgressComponent,
                    RowNumberPipe,
                    SortDirective,
                    PagedPagerComponent,
                    PageSizeDirective,
                    PageNumberDirective,
                    BufferedPagerComponent,
                    InfiniteDirective,
                    RowCountDirective
                ],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RTModule {
    /**
     * @param {?} __0
     * @return {?}
     */
    static registerStateService({ useClass, useValue, useExisting, useFactory, deps, multi }) {
        RTListsModule.registerStateService({ useClass, useValue, useExisting, useFactory, deps, multi });
    }
}
RTModule.decorators = [
    { type: NgModule, args: [{
                exports: [RTListsModule, RTSelectionModule, RTMiscModule, RTFiltersModule],
                imports: [RTListsModule, RTSelectionModule, RTMiscModule, RTFiltersModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { RTModule, RTMiscModule, FocusOnRenderDirective, SelectOnFocusDirective, StopEventsDirective, PreventDefaultsDirective, RTFiltersModule, RegisterAsFilterDirective, RTFiltersService, RTSelectionModule, RTSelectionService, RTSelectionEventsHelper, SelectableDirective, SelectionAreaDirective, SelectionCheckboxForDirective, RTListsModule, RTList, RTBufferedPager, RTPagedPager, RTOperationStatus, RTSortingsService, RTFilterTarget, ListDirective, StatusNoDataComponent, StatusRequestCancelledComponent, StatusDoneComponent, StatusFailedComponent, StatusInitialComponent, StatusInProgressComponent, RowNumberPipe, SortDirective, PagedPagerComponent, PageSizeDirective, PageNumberDirective, BufferedPagerComponent, InfiniteDirective, RowCountDirective, LIST_PROVIDERS, RTStateService, PagerInputBase as b, StatusComponentBase as a, EventsAttacherBase as c };
